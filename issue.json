{"246586361":{"title":"声明式与命令式编程","createdAt":"2017-07-30T14:14:47Z","state":"OPEN","labels":[],"body":"声明\r\n声明我要的是什么。\r\n命令\r\n我要这个我要干什么\r\n```js\r\nvar arrays = [1,2,3,4]\r\nwant to  be [2,4,6,8]\r\nlet len = arrays.length\r\nfor (let i =0;i<len;i++){\r\n    arrays[i] *=2\r\n}\r\n```\r\n命令式。我们指定指出每一步干什么，怎么干，强调了过程\r\n\r\narrays.map((value)=>{return value*2})\r\n声明式，我们指定了目标。我们要什么。强调了结果，目的\r\n\r\n\r\n函数式变成实际上就是声明式编程的子编程范式\r\n摘自wiki\r\n函数式编程，特别是纯函数式编程，尝试最小化状态带来的副作用，因此被认为是宣告式的(声明式)\r\n","author":"ZWkang","databaseId":246586361,"id":"MDU6SXNzdWUyNDY1ODYzNjE=","lastEditedAt":"2019-08-13T07:08:47Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/246586361","bodyHTML":"<p>声明<br>\n声明我要的是什么。<br>\n命令<br>\n我要这个我要干什么</p>\n<pre><code class=\"language-js\">var arrays = [1,2,3,4]\nwant to  be [2,4,6,8]\nlet len = arrays.length\nfor (let i =0;i&lt;len;i++){\n    arrays[i] *=2\n}\n</code></pre>\n<p>命令式。我们指定指出每一步干什么，怎么干，强调了过程</p>\n<p>arrays.map((value)=&gt;{return value*2})<br>\n声明式，我们指定了目标。我们要什么。强调了结果，目的</p>\n<p>函数式变成实际上就是声明式编程的子编程范式<br>\n摘自wiki<br>\n函数式编程，特别是纯函数式编程，尝试最小化状态带来的副作用，因此被认为是宣告式的(声明式)</p>\n","preview":"声明 声明我要的是什么。 命令 我要这个我要干什么 `js var arrays = [1,2,3,4] want to  be [2,4,6,8] let len = arrays.length for (let i..."},"246949076":{"title":"JSX","createdAt":"2017-08-01T04:01:30Z","state":"OPEN","labels":[],"body":"在React使用JSX编写dom\r\n约定大小写来区分html原生标签与React组件\r\n```\r\nimport React,{Component} from 'react'\r\n\r\nclass TestTemp extends Component{\r\n    constructor () {\r\n        super()\r\n    }\r\n    render (){\r\n        return (\r\n            <h1>React Test Template</h1>\r\n        )\r\n    }\r\n}\r\n```\r\n这样子的就是一个React很简单的一个组件demo\r\n我们可以在JSX中使用表达式\r\n像这样\r\n[使用表达式/变量例子](https://jsfiddle.net/69z2wepo/83687/)\r\n\r\n#### if else while之类的是不被允许在JSX中使用的。因为JSX还要进行解析的。\r\n#### style 属性接受由 CSS 属性构成的 JS 对象\r\n\r\nJSX的注释稍显不同\r\n需要使用{}包裹起来\r\n{/* 注释 */}\r\n类似如此\r\n\r\n#### JSX经过babel编译与React.js构造之后变成Javascript对象结构\r\n#### 在经过ReactDOM.render转化为dom元素(这一块应该相当于调用了virtual dom的h函数吧哈哈哈)\r\n\r\n[开始感受这种美妙](https://jsfiddle.net/69z2wepo/83688/)","author":"ZWkang","databaseId":246949076,"id":"MDU6SXNzdWUyNDY5NDkwNzY=","lastEditedAt":"2017-08-06T02:34:14Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/246949076","bodyHTML":"<p>在React使用JSX编写dom<br>\n约定大小写来区分html原生标签与React组件</p>\n<pre><code>import React,{Component} from 'react'\n\nclass TestTemp extends Component{\n    constructor () {\n        super()\n    }\n    render (){\n        return (\n            &lt;h1&gt;React Test Template&lt;/h1&gt;\n        )\n    }\n}\n</code></pre>\n<p>这样子的就是一个React很简单的一个组件demo<br>\n我们可以在JSX中使用表达式<br>\n像这样<br>\n<a href=\"https://jsfiddle.net/69z2wepo/83687/\">使用表达式/变量例子</a></p>\n<h4>if else while之类的是不被允许在JSX中使用的。因为JSX还要进行解析的。</h4>\n<h4>style 属性接受由 CSS 属性构成的 JS 对象</h4>\n<p>JSX的注释稍显不同<br>\n需要使用{}包裹起来<br>\n{/* 注释 */}<br>\n类似如此</p>\n<h4>JSX经过babel编译与React.js构造之后变成Javascript对象结构</h4>\n<h4>在经过ReactDOM.render转化为dom元素(这一块应该相当于调用了virtual dom的h函数吧哈哈哈)</h4>\n<p><a href=\"https://jsfiddle.net/69z2wepo/83688/\">开始感受这种美妙</a></p>\n","preview":"在React使用JSX编写dom 约定大小写来区分html原生标签与React组件 ` import React,{Component} from 'react'  class TestTemp extends Component{    ..."},"263449074":{"title":"事件的监听","createdAt":"2017-10-06T13:38:49Z","state":"OPEN","labels":[],"body":"- 事件绑定只能绑定在**HTML标签**上，不能绑定在**组件标签**上\r\n- 事件绑定需要是用**驼峰式**\r\n- React内部已经对事件绑定的event做了兼容\r\n- 事件通过函数调用。所以调用的时候this**有可能会丢失**。在组件实例绑定的时候onClick = {this.handlerClick.bind(this)} 绑定当前组件实例\r\n- 在要使用event对象的时候且要bind一个事件处理函数\r\n```\r\ntest(name, e){}\r\n```\r\n需要将event放在形参最后","author":"ZWkang","databaseId":263449074,"id":"MDU6SXNzdWUyNjM0NDkwNzQ=","lastEditedAt":"2018-05-02T09:19:39Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/263449074","bodyHTML":"<ul>\n<li>事件绑定只能绑定在<strong>HTML标签</strong>上，不能绑定在<strong>组件标签</strong>上</li>\n<li>事件绑定需要是用<strong>驼峰式</strong></li>\n<li>React内部已经对事件绑定的event做了兼容</li>\n<li>事件通过函数调用。所以调用的时候this<strong>有可能会丢失</strong>。在组件实例绑定的时候onClick = {this.handlerClick.bind(this)} 绑定当前组件实例</li>\n<li>在要使用event对象的时候且要bind一个事件处理函数</li>\n</ul>\n<pre><code>test(name, e){}\n</code></pre>\n<p>需要将event放在形参最后</p>\n","preview":"事件绑定只能绑定在HTML标签上，不能绑定在组件标签上 事件绑定需要是用驼峰式 React内部已经对事件绑定的event做了兼容 事件通过函数调用。所以调用的时候this有可能会丢失。在组件实例绑定的时候onClick =..."},"263449558":{"title":"Props与state","createdAt":"2017-10-06T13:40:17Z","state":"OPEN","labels":[],"body":"- Props 可以视为外部传入状态 state 可以视为组件内部状态\r\n- state 存储组件的状态，就是一些data。\r\n  - 组件可以通过一些state来做渲染组件\r\n  - 通过this.state获取。\r\n  - state是不建议直接修改的。因为这样子，react无法知道你已经修改了state。我们应该调用this.setState 方法来触发视图的更新\r\n  - setState 的延迟性。setState 并不会立即修改。它会起一个队列，在进行合并更新。\r\n  - 我们可以简单的使用函数，来进行修改渲染。从而使得在队列中也能依次\r\n  - ```\r\n    this.setState((prevState) => {\r\n      return { count: prevState.count + 1 } // 上一个 setState 的返回是 count 为 0，当前返回 1\r\n    }) \r\n    ```\r\n  - React 16之后this.setState可以传入null与undefined\r\n- Props让组件独立 并且在一定程度上实现可配置\r\n  - 每个组件都可以接受一个 props 参数，它是一个对象\r\n  - props传入后在组件内不可变，不能修改.this.props.xxx = '' 报错。我们可以通过上层组件进行setState来触发更新，从而使得props传入改变。\r\n  - React提供defaultProps 做默认的props 使得我们不用||判断props是否传入\r\n\r\n- Props 与 state\r\n  - state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。\r\n  - 尽可能的使用props 尽可能少的使用state\r\n  - 状态是很难以管理的。但是状态流的流向是很好确定的。当组件单个都有自己的状态。维护起来相当复杂。而当状态流的确定，props的流向。用来确定的话，那样维护性较好\r\n  - 一些简单组件例如下拉的状态之类的管理，简单的使用state即可了啊\r\n\r\n\r\n```\r\n无状态组件\r\nclass HelloWorld extends Component {\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  sayHi () {\r\n    alert('Hello World')\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <div onClick={this.sayHi.bind(this)}>Hello World</div>\r\n    )\r\n  }\r\n}\r\n```\r\n```\r\n函数式无状态组件\r\nconst HelloWorld = (props) => {\r\n  const sayHi = (event) => alert('Hello World')\r\n  return (\r\n    <div onClick={sayHi}>Hello World</div>\r\n  )\r\n}\r\n```","author":"ZWkang","databaseId":263449558,"id":"MDU6SXNzdWUyNjM0NDk1NTg=","lastEditedAt":"2017-10-06T14:42:36Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/263449558","bodyHTML":"<ul>\n<li>\n<p>Props 可以视为外部传入状态 state 可以视为组件内部状态</p>\n</li>\n<li>\n<p>state 存储组件的状态，就是一些data。</p>\n<ul>\n<li>组件可以通过一些state来做渲染组件</li>\n<li>通过this.state获取。</li>\n<li>state是不建议直接修改的。因为这样子，react无法知道你已经修改了state。我们应该调用this.setState 方法来触发视图的更新</li>\n<li>setState 的延迟性。setState 并不会立即修改。它会起一个队列，在进行合并更新。</li>\n<li>我们可以简单的使用函数，来进行修改渲染。从而使得在队列中也能依次</li>\n<li>\n<pre><code>this.setState((prevState) =&gt; {\n  return { count: prevState.count + 1 } // 上一个 setState 的返回是 count 为 0，当前返回 1\n}) \n</code></pre>\n</li>\n<li>React 16之后this.setState可以传入null与undefined</li>\n</ul>\n</li>\n<li>\n<p>Props让组件独立 并且在一定程度上实现可配置</p>\n<ul>\n<li>每个组件都可以接受一个 props 参数，它是一个对象</li>\n<li>props传入后在组件内不可变，不能修改.this.props.xxx = '' 报错。我们可以通过上层组件进行setState来触发更新，从而使得props传入改变。</li>\n<li>React提供defaultProps 做默认的props 使得我们不用||判断props是否传入</li>\n</ul>\n</li>\n<li>\n<p>Props 与 state</p>\n<ul>\n<li>state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。</li>\n<li>尽可能的使用props 尽可能少的使用state</li>\n<li>状态是很难以管理的。但是状态流的流向是很好确定的。当组件单个都有自己的状态。维护起来相当复杂。而当状态流的确定，props的流向。用来确定的话，那样维护性较好</li>\n<li>一些简单组件例如下拉的状态之类的管理，简单的使用state即可了啊</li>\n</ul>\n</li>\n</ul>\n<pre><code>无状态组件\nclass HelloWorld extends Component {\n  constructor() {\n    super()\n  }\n\n  sayHi () {\n    alert('Hello World')\n  }\n\n  render () {\n    return (\n      &lt;div onClick={this.sayHi.bind(this)}&gt;Hello World&lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<pre><code>函数式无状态组件\nconst HelloWorld = (props) =&gt; {\n  const sayHi = (event) =&gt; alert('Hello World')\n  return (\n    &lt;div onClick={sayHi}&gt;Hello World&lt;/div&gt;\n  )\n}\n</code></pre>\n","preview":"Props 可以视为外部传入状态 state 可以视为组件内部状态 state 存储组件的状态，就是一些data。   组件可以通过一些state来做渲染组件   通过this.state获取。  ..."},"319476208":{"title":"条件渲染","createdAt":"2018-05-02T09:21:25Z","state":"OPEN","labels":[],"body":"可以花括号内使用&&\r\n也可以花括号使用三目运算符\r\n也可以在组件内部判断，然后自行返回null亦或者是组件","author":"ZWkang","databaseId":319476208,"id":"MDU6SXNzdWUzMTk0NzYyMDg=","lastEditedAt":"2018-05-02T09:21:40Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/319476208","bodyHTML":"<p>可以花括号内使用&amp;&amp;<br>\n也可以花括号使用三目运算符<br>\n也可以在组件内部判断，然后自行返回null亦或者是组件</p>\n","preview":"可以花括号内使用&& 也可以花括号使用三目运算符 也可以在组件内部判断，然后自行返回null亦或者是组件..."},"319476779":{"title":"需要在意的小细节","createdAt":"2018-05-02T09:23:16Z","state":"OPEN","labels":[],"body":"1. 唯一key是不会传递给组件的，也就是说props.key是没有的，key只是给react的一个提示\r\n2. 状态提升，在多个兄弟组件中，如果要利用同一数据源，可以非受控，将数据源放在最近的共同父组件中，然后change的function同样也从props取得，从而在change的时候调用props的change从而改变props","author":"ZWkang","databaseId":319476779,"id":"MDU6SXNzdWUzMTk0NzY3Nzk=","lastEditedAt":"2018-05-02T09:29:41Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/319476779","bodyHTML":"<ol>\n<li>唯一key是不会传递给组件的，也就是说props.key是没有的，key只是给react的一个提示</li>\n<li>状态提升，在多个兄弟组件中，如果要利用同一数据源，可以非受控，将数据源放在最近的共同父组件中，然后change的function同样也从props取得，从而在change的时候调用props的change从而改变props</li>\n</ol>\n","preview":"唯一key是不会传递给组件的，也就是说props.key是没有的，key只是给react的一个提示..."},"320719870":{"title":"高阶组件","createdAt":"2018-05-07T08:34:46Z","state":"OPEN","labels":[],"body":"来源\r\n- [深入理解 React 高阶组件](https://zhuanlan.zhihu.com/p/24776678)\r\n- [React Higher Order Components in depth](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)\r\n- [reconciliation](https://reactjs.org/docs/reconciliation.html)\r\n- [React系列之高阶组件HOC实际应用指南](https://juejin.im/post/5a5dc82151882573392cbe37)\r\n- [React高阶组件(HOC)模型理论与实践](https://segmentfault.com/a/1190000008112017#articleHeader13)\r\n- [React高阶组件(HOC)模型理论与实践](https://segmentfault.com/a/1190000008112017#articleHeader13)\r\n- [react进阶之高阶组件](https://github.com/sunyongjian/blog/issues/25)\r\n\r\n高阶组件。说起这个就想起了高阶函数\r\n组件抽象复用\r\n\r\n## PP (props proxy)\r\nprops代理\r\n\r\nhttps://jsfiddle.net/n5u2wwjg/152308/\r\n\r\n通过中间层对组件的props可以操作增删改查等~\r\n\r\n常见\r\n```\r\n<WrapperComponent {...this.props} />\r\n```\r\n\r\n1. 操作props\r\n2. 通过Refs访问实例\r\n3. 提取状态\r\n4. 用其他元素包装WrappedComponent\r\n\r\n1. https://jsfiddle.net/n5u2wwjg/152372/ wrappercomponent提供状态给被包裹组件~~\r\n2. refs访问实例 https://jsfiddle.net/n5u2wwjg/152379/\r\n\r\n## II (Inheritance Inversion)\r\n\r\n继承反转高阶组件无法保证解析完整的子树。\r\n\r\n1. 劫持render方法\r\n2. 操作state\r\n\r\n- 在由 render输出的任何 React 元素中读取、添加、编辑、删除 props\r\n- 读取和修改由 render 输出的 React 元素树\r\n- 有条件地渲染元素树\r\n- 把样式包裹进元素树（就像在 Props Proxy 中的那样）\r\n\r\n\r\n> render 指的是WrappedComponent.render方法\r\n\r\n1. 条件渲染 根据根据props什么的然后条件渲染判断渲染\r\n```\r\nfunction iiHOC(WrappedComponent) {\r\n  return class Enhancer extends WrappedComponent {\r\n    render() {\r\n      if (this.props.loggedIn) {\r\n        return super.render()\r\n      } else {\r\n        return null\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. 修改由 render 方法输出的 React 组件树。\r\n```\r\nfunction iiHOC(WrappedComponent) {\r\n  return class Enhancer extends WrappedComponent {\r\n    render() {\r\n      const elementsTree = super.render()\r\n      let newProps = {};\r\n      if (elementsTree && elementsTree.type === 'input') {\r\n        newProps = {value: 'may the force be with you'}\r\n      }\r\n      const props = Object.assign({}, elementsTree.props, newProps)\r\n      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)\r\n      return newElementsTree\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### 操作state\r\nHOC 可以读取、编辑和删除 WrappedComponent 实例的 state，如果你需要，你也可以给它添加更多的 state。记住，这会搞乱 WrappedComponent 的 state，导致你可能会破坏某些东西。要限制 HOC 读取或添加 state，添加 state 时应该放在单独的命名空间里，而不是和 WrappedComponent 的 state 混在一起。\r\n\r\n```js\r\nexport function IIHOCDEBUGGER(WrappedComponent) {\r\n  return class II extends WrappedComponent {\r\n    render() {\r\n      return (\r\n        <div>\r\n          <h2>HOC Debugger Component</h2>\r\n          <p>Props</p> <pre>{JSON.stringify(this.props, null, 2)}</pre>\r\n          <p>State</p><pre>{JSON.stringify(this.state, null, 2)}</pre>\r\n          {super.render()}\r\n        </div>\r\n      )\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 命名\r\n用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和调试。\r\n\r\n\r\n```js\r\nHOC.displayName = `HOC(${getDisplayName(WrappedComponent)})`\r\n\r\n//或\r\n\r\nclass HOC extends ... {\r\n  static displayName = `HOC(${getDisplayName(WrappedComponent)})`\r\n  ...\r\n}\r\n```\r\n\r\n\r\n#### 附录 A: HOC 和参数\r\n```js\r\nfunction HOCFactoryFactory(...params){\r\n  // do something with params\r\n  return function HOCFactory(WrappedComponent) {\r\n    return class HOC extends React.Component {\r\n      render() {\r\n        return <WrappedComponent {...this.props}/>\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nHOCFactoryFactory(params)(WrappedComponent)\r\n//或\r\n@HOCFatoryFactory(params)\r\nclass WrappedComponent extends React.Component{}\r\n```\r\n\r\n\r\n#### 附录 B: 与父组件的不同\r\n\r\n```js\r\nclass Parent extends React.Component {\r\n    render() {\r\n      return (\r\n        <div>\r\n          {this.props.children}\r\n        </div>\r\n      )\r\n    }\r\n}\r\n\r\nrender((\r\n  <Parent>\r\n    {children}\r\n  </Parent>\r\n  ), mountNode)\r\n```\r\n\r\n\r\n##### 相对 HOC 来说，父组件可以做什么，不可以做什么？\r\n\r\n- 渲染劫持 (在 Inheritance Inversion 一节讲到)\r\n- 操作内部 props (在 Inheritance Inversion 一节讲到)\r\n- 提取 state。但也有它的不足。只有在显式地为它创建钩子函数后，你才能从父组件外面访问到它的 props。这给它增添了一些不必要的限制。\r\n- 用新的 React 组件包裹。这可能是唯一一种父组件比 HOC 好用的情况。HOC 也可以做到。\r\n- 操作子组件会有一些陷阱。例如，当子组件没有单一的根节点时，你得添加一个额外的元素包裹所有的子组件，这让你的代码有些繁琐。在 HOC 中单一的根节点会由 React/JSX语法来确保。\r\n- 父组件可以自由应用到组件树中，不像 HOC 那样需要给每个组件创建一个类。","author":"ZWkang","databaseId":320719870,"id":"MDU6SXNzdWUzMjA3MTk4NzA=","lastEditedAt":"2019-08-13T07:24:10Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/320719870","bodyHTML":"<p>来源</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24776678\">深入理解 React 高阶组件</a></li>\n<li><a href=\"https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e\">React Higher Order Components in depth</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">reconciliation</a></li>\n<li><a href=\"https://juejin.im/post/5a5dc82151882573392cbe37\">React系列之高阶组件HOC实际应用指南</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008112017#articleHeader13\">React高阶组件(HOC)模型理论与实践</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008112017#articleHeader13\">React高阶组件(HOC)模型理论与实践</a></li>\n<li><a href=\"https://github.com/sunyongjian/blog/issues/25\">react进阶之高阶组件</a></li>\n</ul>\n<p>高阶组件。说起这个就想起了高阶函数<br>\n组件抽象复用</p>\n<h2>PP (props proxy)</h2>\n<p>props代理</p>\n<p>https://jsfiddle.net/n5u2wwjg/152308/</p>\n<p>通过中间层对组件的props可以操作增删改查等~</p>\n<p>常见</p>\n<pre><code>&lt;WrapperComponent {...this.props} /&gt;\n</code></pre>\n<ol>\n<li>\n<p>操作props</p>\n</li>\n<li>\n<p>通过Refs访问实例</p>\n</li>\n<li>\n<p>提取状态</p>\n</li>\n<li>\n<p>用其他元素包装WrappedComponent</p>\n</li>\n<li>\n<p>https://jsfiddle.net/n5u2wwjg/152372/ wrappercomponent提供状态给被包裹组件~~</p>\n</li>\n<li>\n<p>refs访问实例 https://jsfiddle.net/n5u2wwjg/152379/</p>\n</li>\n</ol>\n<h2>II (Inheritance Inversion)</h2>\n<p>继承反转高阶组件无法保证解析完整的子树。</p>\n<ol>\n<li>劫持render方法</li>\n<li>操作state</li>\n</ol>\n<ul>\n<li>在由 render输出的任何 React 元素中读取、添加、编辑、删除 props</li>\n<li>读取和修改由 render 输出的 React 元素树</li>\n<li>有条件地渲染元素树</li>\n<li>把样式包裹进元素树（就像在 Props Proxy 中的那样）</li>\n</ul>\n<blockquote>\n<p>render 指的是WrappedComponent.render方法</p>\n</blockquote>\n<ol>\n<li>条件渲染 根据根据props什么的然后条件渲染判断渲染</li>\n</ol>\n<pre><code>function iiHOC(WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    render() {\n      if (this.props.loggedIn) {\n        return super.render()\n      } else {\n        return null\n      }\n    }\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li>修改由 render 方法输出的 React 组件树。</li>\n</ol>\n<pre><code>function iiHOC(WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    render() {\n      const elementsTree = super.render()\n      let newProps = {};\n      if (elementsTree &amp;&amp; elementsTree.type === 'input') {\n        newProps = {value: 'may the force be with you'}\n      }\n      const props = Object.assign({}, elementsTree.props, newProps)\n      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)\n      return newElementsTree\n    }\n  }\n}\n</code></pre>\n<h4>操作state</h4>\n<p>HOC 可以读取、编辑和删除 WrappedComponent 实例的 state，如果你需要，你也可以给它添加更多的 state。记住，这会搞乱 WrappedComponent 的 state，导致你可能会破坏某些东西。要限制 HOC 读取或添加 state，添加 state 时应该放在单独的命名空间里，而不是和 WrappedComponent 的 state 混在一起。</p>\n<pre><code class=\"language-js\">export function IIHOCDEBUGGER(WrappedComponent) {\n  return class II extends WrappedComponent {\n    render() {\n      return (\n        &lt;div&gt;\n          &lt;h2&gt;HOC Debugger Component&lt;/h2&gt;\n          &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;{JSON.stringify(this.props, null, 2)}&lt;/pre&gt;\n          &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/pre&gt;\n          {super.render()}\n        &lt;/div&gt;\n      )\n    }\n  }\n}\n</code></pre>\n<h3>命名</h3>\n<p>用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和调试。</p>\n<pre><code class=\"language-js\">HOC.displayName = `HOC(${getDisplayName(WrappedComponent)})`\n\n//或\n\nclass HOC extends ... {\n  static displayName = `HOC(${getDisplayName(WrappedComponent)})`\n  ...\n}\n</code></pre>\n<h4>附录 A: HOC 和参数</h4>\n<pre><code class=\"language-js\">function HOCFactoryFactory(...params){\n  // do something with params\n  return function HOCFactory(WrappedComponent) {\n    return class HOC extends React.Component {\n      render() {\n        return &lt;WrappedComponent {...this.props}/&gt;\n      }\n    }\n  }\n}\n\nHOCFactoryFactory(params)(WrappedComponent)\n//或\n@HOCFatoryFactory(params)\nclass WrappedComponent extends React.Component{}\n</code></pre>\n<h4>附录 B: 与父组件的不同</h4>\n<pre><code class=\"language-js\">class Parent extends React.Component {\n    render() {\n      return (\n        &lt;div&gt;\n          {this.props.children}\n        &lt;/div&gt;\n      )\n    }\n}\n\nrender((\n  &lt;Parent&gt;\n    {children}\n  &lt;/Parent&gt;\n  ), mountNode)\n</code></pre>\n<h5>相对 HOC 来说，父组件可以做什么，不可以做什么？</h5>\n<ul>\n<li>渲染劫持 (在 Inheritance Inversion 一节讲到)</li>\n<li>操作内部 props (在 Inheritance Inversion 一节讲到)</li>\n<li>提取 state。但也有它的不足。只有在显式地为它创建钩子函数后，你才能从父组件外面访问到它的 props。这给它增添了一些不必要的限制。</li>\n<li>用新的 React 组件包裹。这可能是唯一一种父组件比 HOC 好用的情况。HOC 也可以做到。</li>\n<li>操作子组件会有一些陷阱。例如，当子组件没有单一的根节点时，你得添加一个额外的元素包裹所有的子组件，这让你的代码有些繁琐。在 HOC 中单一的根节点会由 React/JSX语法来确保。</li>\n<li>父组件可以自由应用到组件树中，不像 HOC 那样需要给每个组件创建一个类。</li>\n</ul>\n","preview":"来源 深入理解 React 高阶组件 React Higher Order Components in depth reconciliation React系列之高阶组件HOC实际应用指南 React高阶组件(HOC)模型理论与实践..."},"320837140":{"title":"受控组件与非受控组件","createdAt":"2018-05-07T14:57:18Z","state":"OPEN","labels":[],"body":"受控组件（Controlled Component）\r\n非受控组件（Uncontrolled Component）\r\n\r\n## 受控组件（Controlled Component）\r\n什么叫受控组件呢？\r\nweb开发有一点常用的就是表单，\r\n在表单提交拿值时，\r\n我们将表单元素值存储在state内，并且经过处理函数操作setState改变表单值。\r\n这样的形式就是受控组件了。\r\n（当然，当你使用props的时候，值存在props中，改变元素值改变props这也是一种受控）\r\n\r\n\r\n","author":"ZWkang","databaseId":320837140,"id":"MDU6SXNzdWUzMjA4MzcxNDA=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/320837140","bodyHTML":"<p>受控组件（Controlled Component）<br>\n非受控组件（Uncontrolled Component）</p>\n<h2>受控组件（Controlled Component）</h2>\n<p>什么叫受控组件呢？<br>\nweb开发有一点常用的就是表单，<br>\n在表单提交拿值时，<br>\n我们将表单元素值存储在state内，并且经过处理函数操作setState改变表单值。<br>\n这样的形式就是受控组件了。<br>\n（当然，当你使用props的时候，值存在props中，改变元素值改变props这也是一种受控）</p>\n","preview":"受控组件（Controlled Component） 非受控组件（Uncontrolled Component）  受控组件（Controlled Component） 什么叫受控组件呢？ web开发有一点常用的就是表单，..."},"326808907":{"title":"simpleCreateStore","createdAt":"2018-05-27T11:37:22Z","state":"OPEN","labels":[],"body":"```\r\nconst createStore = (reducer) > {\r\n  let state;\r\n  let listeners = [];\r\n  const getState = () => state;\r\n  const dispatch = (action) => {\r\n    state = reduce(state, action);\r\n    listeners.forEach(listener => listener());\r\n  }\r\n  const subscribe = (listener) => {\r\n    listeners.push(listener);\r\n    return () => {\r\n      listeners = listeners.filter(l => l !== listener)\r\n    };\r\n  }\r\n  dispatch( {} )\r\n  return { getState, dispatch, subscribe};\r\n}\r\n```\r\n\r\n```\r\n// 接受多个reducer\r\n// 对state做遍历执行 找到对应的reducer然后进行处理。\r\nconst combineReducers = (reducers) => {\r\n    return (state = {} ,action )=>{\r\n        return Object.keys(reducers).reduce(\r\n            (nextState,key) => {\r\n                 nextState[key] = reducers[key](state[key],action);\r\n                 return nextState\r\n            },\r\n            {}\r\n        )\r\n    }\r\n}\r\n```","author":"ZWkang","databaseId":326808907,"id":"MDU6SXNzdWUzMjY4MDg5MDc=","lastEditedAt":"2018-05-31T13:29:41Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/326808907","bodyHTML":"<pre><code>const createStore = (reducer) &gt; {\n  let state;\n  let listeners = [];\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; {\n    state = reduce(state, action);\n    listeners.forEach(listener =&gt; listener());\n  }\n  const subscribe = (listener) =&gt; {\n    listeners.push(listener);\n    return () =&gt; {\n      listeners = listeners.filter(l =&gt; l !== listener)\n    };\n  }\n  dispatch( {} )\n  return { getState, dispatch, subscribe};\n}\n</code></pre>\n<pre><code>// 接受多个reducer\n// 对state做遍历执行 找到对应的reducer然后进行处理。\nconst combineReducers = (reducers) =&gt; {\n    return (state = {} ,action )=&gt;{\n        return Object.keys(reducers).reduce(\n            (nextState,key) =&gt; {\n                 nextState[key] = reducers[key](state[key],action);\n                 return nextState\n            },\n            {}\n        )\n    }\n}\n</code></pre>\n","preview":"` const createStore = (reducer) > {   let state;   let listeners = [];   const getState = () => state;   const dispatch..."},"328117591":{"title":"bind this","createdAt":"2018-05-31T12:26:01Z","state":"OPEN","labels":[],"body":"我们经常使用React可以发现组件内部方法调用this时候 一般都不会是组件实例\r\n我们可以发现this可用一般在componentDidMount与render内可用\r\n别的组件方法常常不可用this\r\n这与js的机制有关系\r\n\r\n总结我们稳固this的方法\r\n\r\n```\r\nReact.createClass\r\n```\r\n\r\n```\r\nthis的bind统一放在constructor中bind\r\nconstructor(){\r\n    this.xxx = this.xxx.bind(this)\r\n}\r\n//实例时候绑定this\r\n```\r\n\r\n```\r\n定义方法使用箭头函数\r\nxxx = ()=>{}\r\n```\r\n\r\n```\r\nrender调用处bind\r\nonClick = {this.xxx.bind(xxx)}\r\n```\r\n\r\n```\r\nrender调用处使用箭头绑定 this\r\nonClick = {(e)=>{this.xxx(e)}}\r\n```\r\n","author":"ZWkang","databaseId":328117591,"id":"MDU6SXNzdWUzMjgxMTc1OTE=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/328117591","bodyHTML":"<p>我们经常使用React可以发现组件内部方法调用this时候 一般都不会是组件实例<br>\n我们可以发现this可用一般在componentDidMount与render内可用<br>\n别的组件方法常常不可用this<br>\n这与js的机制有关系</p>\n<p>总结我们稳固this的方法</p>\n<pre><code>React.createClass\n</code></pre>\n<pre><code>this的bind统一放在constructor中bind\nconstructor(){\n    this.xxx = this.xxx.bind(this)\n}\n//实例时候绑定this\n</code></pre>\n<pre><code>定义方法使用箭头函数\nxxx = ()=&gt;{}\n</code></pre>\n<pre><code>render调用处bind\nonClick = {this.xxx.bind(xxx)}\n</code></pre>\n<pre><code>render调用处使用箭头绑定 this\nonClick = {(e)=&gt;{this.xxx(e)}}\n</code></pre>\n","preview":"我们经常使用React可以发现组件内部方法调用this时候 一般都不会是组件实例 我们可以发现this可用一般在componentDidMount与render内可用 别的组件方法常常不可用this 这与js的机制有关系 ..."},"363998215":{"title":"使用注意点","createdAt":"2018-09-26T12:14:23Z","state":"OPEN","labels":[],"body":"1. 了解使用pureComponent\r\n  当父级节点更细的时候，子节点也会对应更新渲染，即使此时的state不需要进行render\r\n  pureComponent 帮我们对state props 做一层浅比较。减少不必要的render操作\r\n2. 一些引用值上的危机\r\n  <TestComponent values={this.props.values || []}/>  如果此时this.props.values 是不存在的话\r\n  则每次都会重新生成一个空数组\r\n```\r\n  const  defaultArray = [];\r\n  <TestComponent values={this.props.values || defaultArray }/>\r\n```\r\n\r\n3. 函数方法的绑定\r\n<TestComponent onChange = { this.handleChange.bind(this)} />\r\n每一次onchange的时候都会生成一个新的函数\r\n引用不一致 导致父组件render 同时导致子组件也进行render\r\n提前绑定  直接传递\r\n@autobind\r\nhandleChange(){}\r\n<TestComponent onChange = { this.handleChange} />\r\n","author":"ZWkang","databaseId":363998215,"id":"MDU6SXNzdWUzNjM5OTgyMTU=","lastEditedAt":"2018-09-26T12:15:53Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/363998215","bodyHTML":"<ol>\n<li>了解使用pureComponent<br>\n当父级节点更细的时候，子节点也会对应更新渲染，即使此时的state不需要进行render<br>\npureComponent 帮我们对state props 做一层浅比较。减少不必要的render操作</li>\n<li>一些引用值上的危机<br>\n&lt;TestComponent values={this.props.values || []}/&gt;  如果此时this.props.values 是不存在的话<br>\n则每次都会重新生成一个空数组</li>\n</ol>\n<pre><code>  const  defaultArray = [];\n  &lt;TestComponent values={this.props.values || defaultArray }/&gt;\n</code></pre>\n<ol start=\"3\">\n<li>函数方法的绑定<br>\n&lt;TestComponent onChange = { this.handleChange.bind(this)} /&gt;<br>\n每一次onchange的时候都会生成一个新的函数<br>\n引用不一致 导致父组件render 同时导致子组件也进行render<br>\n提前绑定  直接传递<br>\n@autobind<br>\nhandleChange(){}<br>\n&lt;TestComponent onChange = { this.handleChange} /&gt;</li>\n</ol>\n","preview":"了解使用pureComponent   当父级节点更细的时候，子节点也会对应更新渲染，即使此时的state不需要进行render   pureComponent 帮我们对state props 做一层浅比较。减少不必要的render操作..."},"376312210":{"title":"small function","createdAt":"2018-11-01T09:16:57Z","state":"OPEN","labels":[],"body":"## React.cloneElement\r\n#### clone一个组件\r\n```\r\nReact.cloneElement(\r\n  element,\r\n  [props],\r\n  [...children]\r\n)\r\nprops 会进行一层浅复制， 甚至会进行ref的保留\r\n\r\n<element></element>\r\n\r\nReact.cloneElement\r\n\r\n===>\r\n\r\n<element {...element.props} {...props} >{children}</element>\r\n\r\n它也保留了ref。这意味着，如果你通过 ref 获取到子级组件时，不会一不小心从祖先组件里窃取了它。你将获得与你新元素相同的ref\r\n```\r\n\r\n## React.isValidElement(object)\r\n\r\n#### 确定对象是否位react元素\r\n\r\n## React.Children.map(children, function[(thisArg)])\r\n\r\n包含在 children 里的每个子级上调用函数，调用的函数的 this 设置为 thisArg\r\n\r\n为null或者undefined会返回null或者undefined\r\n\r\n### forEach,count,only,toArray\r\n\r\n**toArray**\r\n返回以赋key给每个子级 child 的扁平数组形式来组成不透明的 children 数据结构。如果你打算在你的渲染方法里操纵子级集合这很有用，特别是你想在 this.props.children 传下之前对它重新排序或切割。\r\n","author":"ZWkang","databaseId":376312210,"id":"MDU6SXNzdWUzNzYzMTIyMTA=","lastEditedAt":"2018-11-01T09:17:29Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/376312210","bodyHTML":"<h2>React.cloneElement</h2>\n<h4>clone一个组件</h4>\n<pre><code>React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\nprops 会进行一层浅复制， 甚至会进行ref的保留\n\n&lt;element&gt;&lt;/element&gt;\n\nReact.cloneElement\n\n===&gt;\n\n&lt;element {...element.props} {...props} &gt;{children}&lt;/element&gt;\n\n它也保留了ref。这意味着，如果你通过 ref 获取到子级组件时，不会一不小心从祖先组件里窃取了它。你将获得与你新元素相同的ref\n</code></pre>\n<h2>React.isValidElement(object)</h2>\n<h4>确定对象是否位react元素</h4>\n<h2>React.Children.map(children, function[(thisArg)])</h2>\n<p>包含在 children 里的每个子级上调用函数，调用的函数的 this 设置为 thisArg</p>\n<p>为null或者undefined会返回null或者undefined</p>\n<h3>forEach,count,only,toArray</h3>\n<p><strong>toArray</strong><br>\n返回以赋key给每个子级 child 的扁平数组形式来组成不透明的 children 数据结构。如果你打算在你的渲染方法里操纵子级集合这很有用，特别是你想在 this.props.children 传下之前对它重新排序或切割。</p>\n","preview":"React.cloneElement clone一个组件 ` React.cloneElement(   element,   [props],   [...children] ) props 会进行一层浅复制， 甚至会进行ref的保留  ..."},"386055127":{"title":"Learn Resource","createdAt":"2018-11-30T06:27:05Z","state":"OPEN","labels":[],"body":"文档类\r\n[react 英文文档](https://reactjs.org/docs/design-principles.html)\r\n[react 中文翻译文档](https://react.docschina.org/)\r\n[redux 英文文档](https://redux.js.org/)\r\n[redux 中文文档](https://cn.redux.js.org/)\r\n[react-router 英文文档](https://reacttraining.com/react-router/)  建议看英文\r\n[react-router 中文文档](https://react-router.docschina.org/)\r\n[babel 英文文档](https://babeljs.io/)\r\n[babel 中文文档](https://www.babeljs.cn/)\r\n[webpack 英文文档](https://webpack.js.org/)\r\n[webpack 中文文档](https://webpack.docschina.org/concepts/)\r\n\r\n资源\r\n[react bits 中文](https://hateonion.me/books/react-bits-cn/)\r\n[react 模式](https://reactpatterns.com/)\r\n\r\n\r\n\r\n","author":"ZWkang","databaseId":386055127,"id":"MDU6SXNzdWUzODYwNTUxMjc=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/386055127","bodyHTML":"<p>文档类<br>\n<a href=\"https://reactjs.org/docs/design-principles.html\">react 英文文档</a><br>\n<a href=\"https://react.docschina.org/\">react 中文翻译文档</a><br>\n<a href=\"https://redux.js.org/\">redux 英文文档</a><br>\n<a href=\"https://cn.redux.js.org/\">redux 中文文档</a><br>\n<a href=\"https://reacttraining.com/react-router/\">react-router 英文文档</a>  建议看英文<br>\n<a href=\"https://react-router.docschina.org/\">react-router 中文文档</a><br>\n<a href=\"https://babeljs.io/\">babel 英文文档</a><br>\n<a href=\"https://www.babeljs.cn/\">babel 中文文档</a><br>\n<a href=\"https://webpack.js.org/\">webpack 英文文档</a><br>\n<a href=\"https://webpack.docschina.org/concepts/\">webpack 中文文档</a></p>\n<p>资源<br>\n<a href=\"https://hateonion.me/books/react-bits-cn/\">react bits 中文</a><br>\n<a href=\"https://reactpatterns.com/\">react 模式</a></p>\n","preview":"文档类 react 英文文档 react 中文翻译文档 redux 英文文档 redux 中文文档 react-router 英文文档  建议看英文 react-router 中文文档 babel 英文文档 babel 中文文档..."},"414494566":{"title":"React生命周期","createdAt":"2019-02-26T08:47:40Z","state":"OPEN","labels":[],"body":"## react生命周期\r\n> 16.3以前版本\r\n\r\n![react lifecycle](https://upload-images.jianshu.io/upload_images/4118241-d979d05af0b7d4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/webp)\r\n\r\n\r\n### componentWillMount\r\n\r\n> 组件即将被渲染到页面上\r\n\r\n### componentDidMount\r\n\r\n> 组件已经渲染到了页面上，此时可以进行DOM元素操作(常在此进行Ajax请求)\r\n\r\n### componentWillReceiveProps\r\n\r\n> 组件接收到props属性时候触发\r\n\r\n### componentWillUpdate\r\n\r\n> 与componentWillReceiveProps基本相同，除了不能进行setState\r\n\r\n> shouldComponentUpdate为true时使用。\r\n\r\n### shouldComponentUpdate()\r\n\r\n> 组件接收到新的props属性的时候进行触发 (首次渲染不触发)\r\n\r\n> 常用于优化渲染rerender\r\n\r\n### componentWillUnmount()\r\n\r\n> 组件销毁触发\r\n\r\n> 常用于定时器的销毁\r\n\r\n![深入react js技术栈中的图](https://user-images.githubusercontent.com/15853907/54807539-89235b80-4cb8-11e9-85d1-b5542b598d3f.png)\r\n\r\n\r\n\r\n> 16.3以后的\r\n\r\n<img width=\"1103\" alt=\"屏幕快照 2019-03-22 下午3 56 43\" src=\"https://user-images.githubusercontent.com/15853907/54808416-21224480-4cbb-11e9-8e41-99d1ca2368e4.png\">\r\n\r\nhttp://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\r\n","author":"ZWkang","databaseId":414494566,"id":"MDU6SXNzdWU0MTQ0OTQ1NjY=","lastEditedAt":"2019-03-22T07:57:15Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/414494566","bodyHTML":"<h2>react生命周期</h2>\n<blockquote>\n<p>16.3以前版本</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4118241-d979d05af0b7d4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/webp\" alt=\"react lifecycle\"></p>\n<h3>componentWillMount</h3>\n<blockquote>\n<p>组件即将被渲染到页面上</p>\n</blockquote>\n<h3>componentDidMount</h3>\n<blockquote>\n<p>组件已经渲染到了页面上，此时可以进行DOM元素操作(常在此进行Ajax请求)</p>\n</blockquote>\n<h3>componentWillReceiveProps</h3>\n<blockquote>\n<p>组件接收到props属性时候触发</p>\n</blockquote>\n<h3>componentWillUpdate</h3>\n<blockquote>\n<p>与componentWillReceiveProps基本相同，除了不能进行setState</p>\n</blockquote>\n<blockquote>\n<p>shouldComponentUpdate为true时使用。</p>\n</blockquote>\n<h3>shouldComponentUpdate()</h3>\n<blockquote>\n<p>组件接收到新的props属性的时候进行触发 (首次渲染不触发)</p>\n</blockquote>\n<blockquote>\n<p>常用于优化渲染rerender</p>\n</blockquote>\n<h3>componentWillUnmount()</h3>\n<blockquote>\n<p>组件销毁触发</p>\n</blockquote>\n<blockquote>\n<p>常用于定时器的销毁</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15853907/54807539-89235b80-4cb8-11e9-85d1-b5542b598d3f.png\" alt=\"深入react js技术栈中的图\"></p>\n<blockquote>\n<p>16.3以后的</p>\n</blockquote>\n<p>&lt;img width=&quot;1103&quot; alt=&quot;屏幕快照 2019-03-22 下午3 56 43&quot; src=&quot;https://user-images.githubusercontent.com/15853907/54808416-21224480-4cbb-11e9-8e41-99d1ca2368e4.png&quot;&gt;</p>\n<p>http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</p>\n","preview":"react生命周期 16.3以前版本  react lifecycle   componentWillMount  组件即将被渲染到页面上  componentDidMount ..."},"418213108":{"title":"React Hook","createdAt":"2019-03-07T09:40:07Z","state":"OPEN","labels":[],"body":"### React Hook \r\n> React Hook是一个16.8版本出现的。这个概念出现很久了。\r\n今天来试试React hook\r\n\r\n\r\n我觉得最重要的几点\r\n\r\n1. 如何使用。\r\n2. 解决什么痛点。\r\n3. 如何在原有模式下使用。\r\n4. 未来\r\n\r\n### 一个简单的例子\r\n[simple test use with class component ](https://codesandbox.io/s/71lk75p76j)\r\n\r\n[简单使用useEffect](https://codesandbox.io/s/qlok99y17q)\r\n\r\n[简单todolist‘ demo](https://codesandbox.io/s/n5y830410m)\r\n\r\n这里明显可以看到，我们不用在从props上定式拿下eventcallback进行bind我们的回调函数\r\n使用钩子，我们更灵活的绑定了我们的事件(提取了公有方式)\r\n\r\n### 实实在在解决了问题\r\n\r\n1. 组件多层wrapper\r\n2. 生命周期方法的共用\r\n\r\n<xxx.consumer>\r\n{\r\n  props => xxxx\r\n}\r\n</xxx.consumer>\r\n\r\n---\r\nconst xxx = useContext(xxx)\r\n组件只要使用这个xxx就可以了\r\n少了嵌套使用 \r\n\r\n对函数订阅等方法，都可以使用hook进行公用，从此函数就是函数。而不用作为类的方法。\r\n\r\n这与mixin相似，但是却不是mixin实现、\r\n\r\n\r\n\r\n不能在一个条件判断中使用\r\n\r\nif (condition) {\r\n  const xxx = useContext(xxx)\r\n}","author":"ZWkang","databaseId":418213108,"id":"MDU6SXNzdWU0MTgyMTMxMDg=","lastEditedAt":"2019-05-10T08:54:49Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/418213108","bodyHTML":"<h3>React Hook</h3>\n<blockquote>\n<p>React Hook是一个16.8版本出现的。这个概念出现很久了。<br>\n今天来试试React hook</p>\n</blockquote>\n<p>我觉得最重要的几点</p>\n<ol>\n<li>如何使用。</li>\n<li>解决什么痛点。</li>\n<li>如何在原有模式下使用。</li>\n<li>未来</li>\n</ol>\n<h3>一个简单的例子</h3>\n<p><a href=\"https://codesandbox.io/s/71lk75p76j\">simple test use with class component </a></p>\n<p><a href=\"https://codesandbox.io/s/qlok99y17q\">简单使用useEffect</a></p>\n<p><a href=\"https://codesandbox.io/s/n5y830410m\">简单todolist‘ demo</a></p>\n<p>这里明显可以看到，我们不用在从props上定式拿下eventcallback进行bind我们的回调函数<br>\n使用钩子，我们更灵活的绑定了我们的事件(提取了公有方式)</p>\n<h3>实实在在解决了问题</h3>\n<ol>\n<li>组件多层wrapper</li>\n<li>生命周期方法的共用</li>\n</ol>\n<p>&lt;xxx.consumer&gt;<br>\n{<br>\nprops =&gt; xxxx<br>\n}<br>\n&lt;/xxx.consumer&gt;</p>\n<hr>\n<p>const xxx = useContext(xxx)<br>\n组件只要使用这个xxx就可以了<br>\n少了嵌套使用</p>\n<p>对函数订阅等方法，都可以使用hook进行公用，从此函数就是函数。而不用作为类的方法。</p>\n<p>这与mixin相似，但是却不是mixin实现、</p>\n<p>不能在一个条件判断中使用</p>\n<p>if (condition) {<br>\nconst xxx = useContext(xxx)<br>\n}</p>\n","preview":"React Hook React Hook是一个16.8版本出现的。这个概念出现很久了。 今天来试试React hook   我觉得最重要的几点  如何使用。 解决什么痛点。 如何在原有模式下使用。 未来  一个简单的例子 simple..."},"423302205":{"title":"ref","createdAt":"2019-03-20T15:02:53Z","state":"OPEN","labels":[],"body":"render方法后，组件是不会返回实例供我们操作使用的。\r\n\r\nRefs提供了一种访问DOM节点或在render方法中创建的React元素的方法。\r\n\r\n它组件被调用会新建一个实例，而refs就会指向这个实例\r\n\r\n[简单的input ref获取值例子](https://codesandbox.io/s/zxww3pjr13)\r\n[16.3以后的例子](https://codesandbox.io/s/p360oy697q)\r\n\r\n我们也可以通过获得dom的引用从而去修改值\r\nhttps://codesandbox.io/s/4jp88wk7kx\r\n不过建议尽量少用。(refs中的值同样支持字符串。)\r\n\r\n对类组件进行ref操作\r\nhttps://codesandbox.io/s/3831340jkp\r\n获得组件实例后的this。\r\n\r\n对高阶包裹子组件如何获得ref引用呢？\r\n\r\nhttps://codesandbox.io/s/p9r2qkl1jm\r\n如果我们直接对wrappercomponennt进行使用ref，获取的是外部组件\r\n子组件不能穿透获取。\r\n\r\n那我们想。如果我们使用类似callback技术，将callback function在传递给childcomponent。我们是不是就能简单拿到了childcomponent的实例了呢。\r\n\r\nexample:\r\nhttps://codesandbox.io/s/6jmlnmr3r\r\n\r\n16.3以后的版本还多了一个forwardRef的功能 用来转发我们的ref\r\nhttps://codesandbox.io/s/lxlmn93l0l\r\n\r\n这使得我们不用再增加一些无用的get this的function去获取实例。\r\n\r\n方便快捷\r\n\r\n---\r\n\r\nresource:\r\n\r\n- [ref官方文档](https://reactjs.org/docs/refs-and-the-dom.html)\r\n- [ref gist](https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509)\r\n- 深入理解react技术栈\r\n\r\n","author":"ZWkang","databaseId":423302205,"id":"MDU6SXNzdWU0MjMzMDIyMDU=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/423302205","bodyHTML":"<p>render方法后，组件是不会返回实例供我们操作使用的。</p>\n<p>Refs提供了一种访问DOM节点或在render方法中创建的React元素的方法。</p>\n<p>它组件被调用会新建一个实例，而refs就会指向这个实例</p>\n<p><a href=\"https://codesandbox.io/s/zxww3pjr13\">简单的input ref获取值例子</a><br>\n<a href=\"https://codesandbox.io/s/p360oy697q\">16.3以后的例子</a></p>\n<p>我们也可以通过获得dom的引用从而去修改值<br>\nhttps://codesandbox.io/s/4jp88wk7kx<br>\n不过建议尽量少用。(refs中的值同样支持字符串。)</p>\n<p>对类组件进行ref操作<br>\nhttps://codesandbox.io/s/3831340jkp<br>\n获得组件实例后的this。</p>\n<p>对高阶包裹子组件如何获得ref引用呢？</p>\n<p>https://codesandbox.io/s/p9r2qkl1jm<br>\n如果我们直接对wrappercomponennt进行使用ref，获取的是外部组件<br>\n子组件不能穿透获取。</p>\n<p>那我们想。如果我们使用类似callback技术，将callback function在传递给childcomponent。我们是不是就能简单拿到了childcomponent的实例了呢。</p>\n<p>example:<br>\nhttps://codesandbox.io/s/6jmlnmr3r</p>\n<p>16.3以后的版本还多了一个forwardRef的功能 用来转发我们的ref<br>\nhttps://codesandbox.io/s/lxlmn93l0l</p>\n<p>这使得我们不用再增加一些无用的get this的function去获取实例。</p>\n<p>方便快捷</p>\n<hr>\n<p>resource:</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/refs-and-the-dom.html\">ref官方文档</a></li>\n<li><a href=\"https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509\">ref gist</a></li>\n<li>深入理解react技术栈</li>\n</ul>\n","preview":"render方法后，组件是不会返回实例供我们操作使用的。  Refs提供了一种访问DOM节点或在render方法中创建的React元素的方法。  它组件被调用会新建一个实例，而refs就会指向这个实例  简单的input ref获取值例子..."},"424081788":{"title":"pic save","createdAt":"2019-03-22T07:38:02Z","state":"OPEN","labels":[],"body":"<img width=\"934\" alt=\"屏幕快照 2019-03-22 下午3 37 03\" src=\"https://user-images.githubusercontent.com/15853907/54807515-7741b880-4cb8-11e9-8d6b-183d2c261573.png\">\r\n","author":"ZWkang","databaseId":424081788,"id":"MDU6SXNzdWU0MjQwODE3ODg=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/424081788","bodyHTML":"<p>&lt;img width=&quot;934&quot; alt=&quot;屏幕快照 2019-03-22 下午3 37 03&quot; src=&quot;https://user-images.githubusercontent.com/15853907/54807515-7741b880-4cb8-11e9-8d6b-183d2c261573.png&quot;&gt;</p>\n","preview":" ..."},"438071055":{"title":"cloneElement的小用法","createdAt":"2019-04-28T15:53:08Z","state":"OPEN","labels":[],"body":"用于像多子组件注入\r\n\r\ndemo示例\r\n\r\nhttps://codesandbox.io/s/yjr0x9yoz9\r\n\r\n\r\n显然我们可以通过硬编码完成一些组件开发\r\n```\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Container />\r\n    </div>\r\n  );\r\n}\r\n\r\nconst Item = ({ value, onClick, children }) => (\r\n  <button onClick={onClick}>\r\n    {value}\r\n    {children}\r\n  </button>\r\n);\r\n\r\nclass Container extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      selected: \"none\"\r\n    };\r\n  }\r\n  handleSelect(selected) {\r\n    this.setState({ selected });\r\n  }\r\n  render() {\r\n    const { selected } = this.state;\r\n    return (\r\n      <div>\r\n        <h1>slector: {selected}</h1>\r\n        <Item onClick={this.handleSelect.bind(this, \"A\")}>A</Item>\r\n        <Item onClick={this.handleSelect.bind(this, \"B\")}>B</Item>\r\n        <Item onClick={this.handleSelect.bind(this, \"C\")}>C</Item>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n但是这样的缺点就是，我们不能很灵活的去处理事件内部。这还是在子组件内部类型只有一种的情况下。\r\n\r\n如何使得组件更灵活复用呢。\r\n\r\n通过React.Children的使用 使得我们组件容器可以感知子组件。加上cloneElement从而注入不同的状态与props。\r\n\r\n而子组件的区分也可以通过displayName来区分。\r\n\r\n于是乎，硬编码的方式可以被改良为\r\n```\r\nimport React, { Component } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport \"./styles.css\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Container>\r\n        <Item value=\"A\" />\r\n        <Item value=\"B\" />\r\n        <Item value=\"C\" />\r\n        <button value=\"ceshi\"> ceshi</button>\r\n      </Container>\r\n    </div>\r\n  );\r\n}\r\n\r\nlet Item = ({ value, onClick, children }) => (\r\n  <button onClick={onClick}>\r\n    {value}\r\n    {children}\r\n  </button>\r\n);\r\nItem.displayName = \"Item\";\r\n\r\nclass Container extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      selected: \"none\"\r\n    };\r\n  }\r\n  handleSelect(selected) {\r\n    this.setState({ selected });\r\n  }\r\n  render() {\r\n    const { selected } = this.state;\r\n    const { children } = this.props;\r\n    const fn = child => {\r\n      if (child.type.displayName === \"Item\") {\r\n        return React.cloneElement(child, {\r\n          onClick: this.handleSelect.bind(this, child.props.value)\r\n        });\r\n      } else {\r\n        return child;\r\n      }\r\n    };\r\n    return (\r\n      <div>\r\n        <h1>slector: {selected}</h1>\r\n        {React.Children.map(children, fn)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<App />, rootElement);\r\n```\r\n\r\n这种形态下，对Item的React元素注入onClick事件。\r\n\r\n但是这种形式下也有一些脆弱的地方，如果子组件被一些别的组件包裹。\r\n\r\n此时我们的子组件已经不是原来的子组件了，它经历了clone操作。\r\n\r\n那此时被包裹的元素传递的状态等等就获取不了了。\r\n\r\n// https://codesandbox.io/s/yjr0x9yoz9 查看demo2\r\n\r\n还有\r\n\r\n1. 奇怪地使用displayName\r\n\r\n2. 只能使用children map来遍历子组件\r\n\r\n3. 必须要克隆需要传递的目标子组件\r\n\r\n它很容易随着子组件类型增多而膨胀\r\n\r\n```\r\n{React.Children.map(this.props.children, child => {\r\n  if (child.type.displayName === 'Thing') {}\r\n\r\n  if (child.type.displayName === 'OtherThing') {}\r\n})}\r\n```\r\n\r\n组件应该可以在组件树访问。\r\n\r\n子组件应该准确获得它需要的数据源state。\r\n\r\n不需要从cloneElement获得数据传递。\r\n\r\n// https://codesandbox.io/s/yjr0x9yoz9 demo3\r\n\r\n我们只需要从上下文context中取出我们需要的东西就可以了。\r\n\r\n这样子很灵活可以使用，再增加类型我们也不用增加样板代码。。\r\n\r\n将处理压力给了子组件，极大程度上减少了父子组件之间的耦合\r\n","author":"ZWkang","databaseId":438071055,"id":"MDU6SXNzdWU0MzgwNzEwNTU=","lastEditedAt":"2019-04-28T17:01:30Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/438071055","bodyHTML":"<p>用于像多子组件注入</p>\n<p>demo示例</p>\n<p>https://codesandbox.io/s/yjr0x9yoz9</p>\n<p>显然我们可以通过硬编码完成一些组件开发</p>\n<pre><code>function App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;Container /&gt;\n    &lt;/div&gt;\n  );\n}\n\nconst Item = ({ value, onClick, children }) =&gt; (\n  &lt;button onClick={onClick}&gt;\n    {value}\n    {children}\n  &lt;/button&gt;\n);\n\nclass Container extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: &quot;none&quot;\n    };\n  }\n  handleSelect(selected) {\n    this.setState({ selected });\n  }\n  render() {\n    const { selected } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;slector: {selected}&lt;/h1&gt;\n        &lt;Item onClick={this.handleSelect.bind(this, &quot;A&quot;)}&gt;A&lt;/Item&gt;\n        &lt;Item onClick={this.handleSelect.bind(this, &quot;B&quot;)}&gt;B&lt;/Item&gt;\n        &lt;Item onClick={this.handleSelect.bind(this, &quot;C&quot;)}&gt;C&lt;/Item&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>\n<p>但是这样的缺点就是，我们不能很灵活的去处理事件内部。这还是在子组件内部类型只有一种的情况下。</p>\n<p>如何使得组件更灵活复用呢。</p>\n<p>通过React.Children的使用 使得我们组件容器可以感知子组件。加上cloneElement从而注入不同的状态与props。</p>\n<p>而子组件的区分也可以通过displayName来区分。</p>\n<p>于是乎，硬编码的方式可以被改良为</p>\n<pre><code>import React, { Component } from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n\nimport &quot;./styles.css&quot;;\n\nfunction App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;Container&gt;\n        &lt;Item value=&quot;A&quot; /&gt;\n        &lt;Item value=&quot;B&quot; /&gt;\n        &lt;Item value=&quot;C&quot; /&gt;\n        &lt;button value=&quot;ceshi&quot;&gt; ceshi&lt;/button&gt;\n      &lt;/Container&gt;\n    &lt;/div&gt;\n  );\n}\n\nlet Item = ({ value, onClick, children }) =&gt; (\n  &lt;button onClick={onClick}&gt;\n    {value}\n    {children}\n  &lt;/button&gt;\n);\nItem.displayName = &quot;Item&quot;;\n\nclass Container extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: &quot;none&quot;\n    };\n  }\n  handleSelect(selected) {\n    this.setState({ selected });\n  }\n  render() {\n    const { selected } = this.state;\n    const { children } = this.props;\n    const fn = child =&gt; {\n      if (child.type.displayName === &quot;Item&quot;) {\n        return React.cloneElement(child, {\n          onClick: this.handleSelect.bind(this, child.props.value)\n        });\n      } else {\n        return child;\n      }\n    };\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;slector: {selected}&lt;/h1&gt;\n        {React.Children.map(children, fn)}\n      &lt;/div&gt;\n    );\n  }\n}\nconst rootElement = document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<p>这种形态下，对Item的React元素注入onClick事件。</p>\n<p>但是这种形式下也有一些脆弱的地方，如果子组件被一些别的组件包裹。</p>\n<p>此时我们的子组件已经不是原来的子组件了，它经历了clone操作。</p>\n<p>那此时被包裹的元素传递的状态等等就获取不了了。</p>\n<p>// https://codesandbox.io/s/yjr0x9yoz9 查看demo2</p>\n<p>还有</p>\n<ol>\n<li>\n<p>奇怪地使用displayName</p>\n</li>\n<li>\n<p>只能使用children map来遍历子组件</p>\n</li>\n<li>\n<p>必须要克隆需要传递的目标子组件</p>\n</li>\n</ol>\n<p>它很容易随着子组件类型增多而膨胀</p>\n<pre><code>{React.Children.map(this.props.children, child =&gt; {\n  if (child.type.displayName === 'Thing') {}\n\n  if (child.type.displayName === 'OtherThing') {}\n})}\n</code></pre>\n<p>组件应该可以在组件树访问。</p>\n<p>子组件应该准确获得它需要的数据源state。</p>\n<p>不需要从cloneElement获得数据传递。</p>\n<p>// https://codesandbox.io/s/yjr0x9yoz9 demo3</p>\n<p>我们只需要从上下文context中取出我们需要的东西就可以了。</p>\n<p>这样子很灵活可以使用，再增加类型我们也不用增加样板代码。。</p>\n<p>将处理压力给了子组件，极大程度上减少了父子组件之间的耦合</p>\n","preview":"用于像多子组件注入  demo示例  https://codesandbox.io/s/yjr0x9yoz9   显然我们可以通过硬编码完成一些组件开发 ` function App() {   return (      ); } ..."},"441741538":{"title":"当setstate调用时组件已被卸载或者还未被didmount","createdAt":"2019-05-08T13:41:37Z","state":"OPEN","labels":[],"body":"当还没被挂载或者已经被卸载的组件调用setState会得到一个警告\r\n\r\n例子:\r\n\r\nhttps://codesandbox.io/s/jvroxlzjp5\r\n\r\n而这种情况。我们可以用一个状态量来将其设置是否允许setState\r\n\r\n例子:\r\n\r\nhttps://codesandbox.io/s/x2vxk9km7p\r\n\r\n使用高阶做一下封装\r\n\r\nhttps://codesandbox.io/s/30q2l75n51\r\n\r\n不过React官方是建议\r\nhttps://reactjs.org/blog/2015/12/16/ismounted-antipattern.html\r\n\r\n\r\n建议在异步调用setState处做出处理。\r\n\r\n例如\r\n```js\r\nclass MyComponent extends React.Component {\r\n  componentDidMount() {\r\n    mydatastore.subscribe(this);\r\n  }\r\n  render() {\r\n    ...\r\n  }\r\n  componentWillUnmount() {\r\n    mydatastore.unsubscribe(this);\r\n  }\r\n}\r\n```\r\n订阅后取消订阅\r\n\r\n```js\r\nconst makeCancelable = (promise) => {\r\n  let hasCanceled_ = false;\r\n\r\n  const wrappedPromise = new Promise((resolve, reject) => {\r\n    promise.then(\r\n      val => hasCanceled_ ? reject({isCanceled: true}) : resolve(val),\r\n      error => hasCanceled_ ? reject({isCanceled: true}) : reject(error)\r\n    );\r\n  });\r\n\r\n  return {\r\n    promise: wrappedPromise,\r\n    cancel() {\r\n      hasCanceled_ = true;\r\n    },\r\n  };\r\n};\r\n```\r\n\r\n让promise的链式调用可以被取消","author":"ZWkang","databaseId":441741538,"id":"MDU6SXNzdWU0NDE3NDE1Mzg=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/441741538","bodyHTML":"<p>当还没被挂载或者已经被卸载的组件调用setState会得到一个警告</p>\n<p>例子:</p>\n<p>https://codesandbox.io/s/jvroxlzjp5</p>\n<p>而这种情况。我们可以用一个状态量来将其设置是否允许setState</p>\n<p>例子:</p>\n<p>https://codesandbox.io/s/x2vxk9km7p</p>\n<p>使用高阶做一下封装</p>\n<p>https://codesandbox.io/s/30q2l75n51</p>\n<p>不过React官方是建议<br>\nhttps://reactjs.org/blog/2015/12/16/ismounted-antipattern.html</p>\n<p>建议在异步调用setState处做出处理。</p>\n<p>例如</p>\n<pre><code class=\"language-js\">class MyComponent extends React.Component {\n  componentDidMount() {\n    mydatastore.subscribe(this);\n  }\n  render() {\n    ...\n  }\n  componentWillUnmount() {\n    mydatastore.unsubscribe(this);\n  }\n}\n</code></pre>\n<p>订阅后取消订阅</p>\n<pre><code class=\"language-js\">const makeCancelable = (promise) =&gt; {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise((resolve, reject) =&gt; {\n    promise.then(\n      val =&gt; hasCanceled_ ? reject({isCanceled: true}) : resolve(val),\n      error =&gt; hasCanceled_ ? reject({isCanceled: true}) : reject(error)\n    );\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n</code></pre>\n<p>让promise的链式调用可以被取消</p>\n","preview":"当还没被挂载或者已经被卸载的组件调用setState会得到一个警告  例子:  https://codesandbox.io/s/jvroxlzjp5  而这种情况。我们可以用一个状态量来将其设置是否允许setState  例子: ..."},"442610266":{"title":"React 使用动画几个库的比对demo","createdAt":"2019-05-10T08:54:15Z","state":"OPEN","labels":[],"body":"https://codesandbox.io/s/7271knp34j\r\n\r\n参考文章有些demo失效，这边再做一下调整\r\nmore：\r\n\r\nhttps://medium.com/@dmitrynozhenko/5-ways-to-animate-a-reactjs-app-in-2019-56eb9af6e3bf\r\n\r\nhttps://tech.youzan.com/react-animations/","author":"ZWkang","databaseId":442610266,"id":"MDU6SXNzdWU0NDI2MTAyNjY=","lastEditedAt":"2019-05-10T10:07:20Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/442610266","bodyHTML":"<p>https://codesandbox.io/s/7271knp34j</p>\n<p>参考文章有些demo失效，这边再做一下调整<br>\nmore：</p>\n<p>https://medium.com/@dmitrynozhenko/5-ways-to-animate-a-reactjs-app-in-2019-56eb9af6e3bf</p>\n<p>https://tech.youzan.com/react-animations/</p>\n","preview":"https://codesandbox.io/s/7271knp34j  参考文章有些demo失效，这边再做一下调整 more： ..."},"442740611":{"title":"Suspense ","createdAt":"2019-05-10T14:13:16Z","state":"OPEN","labels":[{"name":"POST"}],"body":"https://github.com/lihongxun945/myblog/issues/38","author":"ZWkang","databaseId":442740611,"id":"MDU6SXNzdWU0NDI3NDA2MTE=","lastEditedAt":"2019-05-10T14:15:51Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/442740611","bodyHTML":"<p>https://github.com/lihongxun945/myblog/issues/38</p>\n","preview":"https://github.com/lihongxun945/myblog/issues/38..."},"481843376":{"title":"展示和容器组件Presentational and Container Components","createdAt":"2019-08-17T03:44:05Z","state":"OPEN","labels":[],"body":"[文章地址](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)\r\n\r\n这里有一些简单的模式，当我写react应用的时候经常用到，如果你一直在走react，你也许早已经发现过它，这篇文章解释得很好，但我想补充几点。 如果将它们分为两类，你会发现你的组件更容易重用和合理，我称他们为容器组件，演示组件\r\n\r\n### 我的展示组件\r\n\r\n关心组件长啥样\r\n可能包含表示组件和容器组件，通常里面有自己的一些DOM标记和样式 - 经常允许通过this.props.children容纳\r\n对应用程序的其他部分没有依赖关系，例如Flux操作或store\r\n不要指定数据如何加载或者如何变化\r\n获取数据和callback只通过props\r\n很少拥有他们自己的状态（当他们这样做的话，它应该是UI状态而不是数据）\r\n类似功能组件编写，除非它们需要状态，生命周期挂钩或性能优化。\r\n例如： Page, Sidebar, Story, UserInfo, List\r\n\r\n### 我的容器组件\r\n关心组件干什么\r\n可能包含容器组件展示组件，在内部但通常没有任何自己的DOM标记，除了一些包装divs，并且从来没有任何样式。\r\n将数据与行为给展示组件或者其它容器组件\r\n调用Flux action并将它们作为回调传递给展示组件\r\n往往是有状态的，因为它们倾向于作为数据源。\r\n通常使用高阶组件生成，例如React Redux的connect（），Relay的createContainer（）或Flux Utils的Container.create（），而不是手工编写。\r\nExamples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList. -\r\n\r\n### 一般放置在不同文件夹下\r\n更好的分离问题。 通过这种方式编写组件，您可以更好地理解您的应用和用户界面 - 更好的可重用性。 您可以将完全不同的状态源使用相同的表示组件，并将它们转换为可以进一步重用的单独的容器组件。 演示组件基本上是您的应用程序的“调色板”。\r\n您可以将它们放在单个页面上，让设计师调整所有变体，而不必触摸应用程序的逻辑。\r\n您可以在该页面上运行屏幕截图回归测试。\r\n这迫使您提取诸如侧边栏，页面，上下文菜单等“布局组件”并使用this.props.children，而不是在多个容器组件中复制相同的标记和布局。\r\n请记住，组件不必发出DOM。 他们只需要在UI关注点之间提供构图边界。","author":"ZWkang","databaseId":481843376,"id":"MDU6SXNzdWU0ODE4NDMzNzY=","lastEditedAt":"2019-08-17T03:44:14Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/481843376","bodyHTML":"<p><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">文章地址</a></p>\n<p>这里有一些简单的模式，当我写react应用的时候经常用到，如果你一直在走react，你也许早已经发现过它，这篇文章解释得很好，但我想补充几点。 如果将它们分为两类，你会发现你的组件更容易重用和合理，我称他们为容器组件，演示组件</p>\n<h3>我的展示组件</h3>\n<p>关心组件长啥样<br>\n可能包含表示组件和容器组件，通常里面有自己的一些DOM标记和样式 - 经常允许通过this.props.children容纳<br>\n对应用程序的其他部分没有依赖关系，例如Flux操作或store<br>\n不要指定数据如何加载或者如何变化<br>\n获取数据和callback只通过props<br>\n很少拥有他们自己的状态（当他们这样做的话，它应该是UI状态而不是数据）<br>\n类似功能组件编写，除非它们需要状态，生命周期挂钩或性能优化。<br>\n例如： Page, Sidebar, Story, UserInfo, List</p>\n<h3>我的容器组件</h3>\n<p>关心组件干什么<br>\n可能包含容器组件展示组件，在内部但通常没有任何自己的DOM标记，除了一些包装divs，并且从来没有任何样式。<br>\n将数据与行为给展示组件或者其它容器组件<br>\n调用Flux action并将它们作为回调传递给展示组件<br>\n往往是有状态的，因为它们倾向于作为数据源。<br>\n通常使用高阶组件生成，例如React Redux的connect（），Relay的createContainer（）或Flux Utils的Container.create（），而不是手工编写。<br>\nExamples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList. -</p>\n<h3>一般放置在不同文件夹下</h3>\n<p>更好的分离问题。 通过这种方式编写组件，您可以更好地理解您的应用和用户界面 - 更好的可重用性。 您可以将完全不同的状态源使用相同的表示组件，并将它们转换为可以进一步重用的单独的容器组件。 演示组件基本上是您的应用程序的“调色板”。<br>\n您可以将它们放在单个页面上，让设计师调整所有变体，而不必触摸应用程序的逻辑。<br>\n您可以在该页面上运行屏幕截图回归测试。<br>\n这迫使您提取诸如侧边栏，页面，上下文菜单等“布局组件”并使用this.props.children，而不是在多个容器组件中复制相同的标记和布局。<br>\n请记住，组件不必发出DOM。 他们只需要在UI关注点之间提供构图边界。</p>\n","preview":"文章地址  这里有一些简单的模式，当我写react应用的时候经常用到，如果你一直在走react，你也许早已经发现过它，这篇文章解释得很好，但我想补充几点。 如果将它们分为两类，你会发现你的组件更容易重用和合理，我称他们为容器组件，演示组件 ..."},"481859627":{"title":"some react patterns","createdAt":"2019-08-17T07:40:44Z","state":"OPEN","labels":[],"body":"react 灵活 带来的模式也很多。\r\n\r\n本篇主要是描述两种模式\r\n\r\n- compound component\r\n- render props\r\n\r\n---\r\n\r\n从例子了解痛点。\r\n\r\n[demo1.js  simple case ](https://codesandbox.io/s/yjr0x9yoz9)\r\n\r\n可以看到一个组件内部自行使用子组件。\r\n\r\n如果组件Container内部一旦有什么改动，那么整个Container就需要进行重写。\r\n\r\n这样一来，组件复用就在恒定模式下复用，而不能灵活使用。\r\n\r\n---\r\n\r\n[demo2.js ](https://codesandbox.io/s/yjr0x9yoz9)\r\n\r\n>  具体实现可以使用React.cloneElement进行对子组件的判断以及props state的注入。\r\n\r\n我们如果将Container只是充当我们数据的提供者。\r\n\r\n也就是说原有Container中的数据都提取到一层。将内部使用子组件部分提取出来。\r\n\r\n- Container(state, props)\r\n  - Item (props)\r\n\r\n====>\r\n\r\n-Container (state, props)\r\n- Container.item (props)\r\n\r\n使用上的差异\r\n\r\n```js\r\n<Contaner {...props} />\r\n<Container ><Container.Item/></Container>\r\n```\r\n\r\n这样一来子组件就可以与上一层Container拆分，不过多耦合。\r\n\r\n----\r\n\r\n这样以来又引申到了另一个问题。\r\n\r\n拆分后的\r\n\r\n```\r\n<Container ><Container.Item/></Container>\r\n```\r\n\r\n如果使用情况稍微改变一下\r\n\r\n```js\r\n<Container>\r\n<Container.Item/>\r\n<div>\r\n <Item.Header />\r\n  <Container.Item />\r\n</div>\r\n</Container>\r\n```\r\n[demo3.js 例子演示](https://codesandbox.io/s/yjr0x9yoz9)\r\n\r\n这样子的话React.children处理子组件的时候，Container.Item不再是直接子组件，这样子的情况会出现props丢失，结果不符合预期等情况。。\r\n\r\n这样一来好像就牵扯出了一个问题。\r\n\r\n类似于多层组件传值的问题。\r\n\r\nreact在当中有context api.\r\n\r\n在局部范围内 Container，我们可以对Container原有的数据抽象为Container.context\r\n\r\n在子组件Container.Item 利用context api 创建消费者进行获取。\r\n\r\n这样以来，就可以避免由于原有子组件不是直接子组件所带来的问题。\r\n\r\n---\r\n\r\n## render props\r\n\r\n上面说了，将父组件抽象为数据提供者用来做分离。\r\n\r\nrender props则是更抽象的分离。\r\n\r\n一般来说，我们可以说render props 与 HOC基本是对等的。HOC能完成的render props也可以。\r\n\r\n我们知道，react props可以传递函数 字符串等等。\r\n\r\n那么我们也可以利用传递的props 回调函数返回jsx进行render。\r\n\r\n这样一来，父组件就彻底沦为了数据的单一提供者，还有渲染的控制者。\r\n\r\n渲染的细节完全取决于子组件本身传递的render props\r\n\r\n官网也有描述render props的文档。可以进行查阅。\r\n\r\n[render props](https://www.reactjscn.com/docs/render-props.html)\r\n\r\n\r\n### render props hell\r\n\r\n如果你常使用render props 很容易会发现一个很恐怖的render props hell\r\n\r\n```\r\n<Text>\r\n  {(word) => {\r\n    return (\r\n      <Test word={word}>\r\n        {(data) => {\r\n          return <h1>data</h1>\r\n        }}\r\n      </Test>\r\n    )\r\n  }}\r\n</Text>\r\n```\r\n\r\n类似以上描述。\r\n\r\n我们可以将props callback 转化为函数，以函数调用尽可能的肉眼消除这些问题。\r\n\r\n```\r\n<Text>\r\n  {this.handleRenderWord}\r\n</Text>\r\n```\r\n\r\n---\r\n\r\nall thanks !!\r\n\r\n[blog link](http://zwkang.com)\r\n","author":"ZWkang","databaseId":481859627,"id":"MDU6SXNzdWU0ODE4NTk2Mjc=","lastEditedAt":"2019-08-17T07:49:12Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/481859627","bodyHTML":"<p>react 灵活 带来的模式也很多。</p>\n<p>本篇主要是描述两种模式</p>\n<ul>\n<li>compound component</li>\n<li>render props</li>\n</ul>\n<hr>\n<p>从例子了解痛点。</p>\n<p><a href=\"https://codesandbox.io/s/yjr0x9yoz9\">demo1.js  simple case </a></p>\n<p>可以看到一个组件内部自行使用子组件。</p>\n<p>如果组件Container内部一旦有什么改动，那么整个Container就需要进行重写。</p>\n<p>这样一来，组件复用就在恒定模式下复用，而不能灵活使用。</p>\n<hr>\n<p><a href=\"https://codesandbox.io/s/yjr0x9yoz9\">demo2.js </a></p>\n<blockquote>\n<p>具体实现可以使用React.cloneElement进行对子组件的判断以及props state的注入。</p>\n</blockquote>\n<p>我们如果将Container只是充当我们数据的提供者。</p>\n<p>也就是说原有Container中的数据都提取到一层。将内部使用子组件部分提取出来。</p>\n<ul>\n<li>Container(state, props)\n<ul>\n<li>Item (props)</li>\n</ul>\n</li>\n</ul>\n<p>====&gt;</p>\n<p>-Container (state, props)</p>\n<ul>\n<li>Container.item (props)</li>\n</ul>\n<p>使用上的差异</p>\n<pre><code class=\"language-js\">&lt;Contaner {...props} /&gt;\n&lt;Container &gt;&lt;Container.Item/&gt;&lt;/Container&gt;\n</code></pre>\n<p>这样一来子组件就可以与上一层Container拆分，不过多耦合。</p>\n<hr>\n<p>这样以来又引申到了另一个问题。</p>\n<p>拆分后的</p>\n<pre><code>&lt;Container &gt;&lt;Container.Item/&gt;&lt;/Container&gt;\n</code></pre>\n<p>如果使用情况稍微改变一下</p>\n<pre><code class=\"language-js\">&lt;Container&gt;\n&lt;Container.Item/&gt;\n&lt;div&gt;\n &lt;Item.Header /&gt;\n  &lt;Container.Item /&gt;\n&lt;/div&gt;\n&lt;/Container&gt;\n</code></pre>\n<p><a href=\"https://codesandbox.io/s/yjr0x9yoz9\">demo3.js 例子演示</a></p>\n<p>这样子的话React.children处理子组件的时候，Container.Item不再是直接子组件，这样子的情况会出现props丢失，结果不符合预期等情况。。</p>\n<p>这样一来好像就牵扯出了一个问题。</p>\n<p>类似于多层组件传值的问题。</p>\n<p>react在当中有context api.</p>\n<p>在局部范围内 Container，我们可以对Container原有的数据抽象为Container.context</p>\n<p>在子组件Container.Item 利用context api 创建消费者进行获取。</p>\n<p>这样以来，就可以避免由于原有子组件不是直接子组件所带来的问题。</p>\n<hr>\n<h2>render props</h2>\n<p>上面说了，将父组件抽象为数据提供者用来做分离。</p>\n<p>render props则是更抽象的分离。</p>\n<p>一般来说，我们可以说render props 与 HOC基本是对等的。HOC能完成的render props也可以。</p>\n<p>我们知道，react props可以传递函数 字符串等等。</p>\n<p>那么我们也可以利用传递的props 回调函数返回jsx进行render。</p>\n<p>这样一来，父组件就彻底沦为了数据的单一提供者，还有渲染的控制者。</p>\n<p>渲染的细节完全取决于子组件本身传递的render props</p>\n<p>官网也有描述render props的文档。可以进行查阅。</p>\n<p><a href=\"https://www.reactjscn.com/docs/render-props.html\">render props</a></p>\n<h3>render props hell</h3>\n<p>如果你常使用render props 很容易会发现一个很恐怖的render props hell</p>\n<pre><code>&lt;Text&gt;\n  {(word) =&gt; {\n    return (\n      &lt;Test word={word}&gt;\n        {(data) =&gt; {\n          return &lt;h1&gt;data&lt;/h1&gt;\n        }}\n      &lt;/Test&gt;\n    )\n  }}\n&lt;/Text&gt;\n</code></pre>\n<p>类似以上描述。</p>\n<p>我们可以将props callback 转化为函数，以函数调用尽可能的肉眼消除这些问题。</p>\n<pre><code>&lt;Text&gt;\n  {this.handleRenderWord}\n&lt;/Text&gt;\n</code></pre>\n<hr>\n<p>all thanks !!</p>\n<p><a href=\"http://zwkang.com\">blog link</a></p>\n","preview":"react 灵活 带来的模式也很多。  本篇主要是描述两种模式  compound component render props    从例子了解痛点。  demo1.js  simple case  可以看到一个组件内部自行使用子组件。 ..."},"481864069":{"title":"避免rerender 的一些方法","createdAt":"2019-08-17T08:38:34Z","state":"OPEN","labels":[],"body":"此篇主要是使用context api一些避免无谓re-render的场景\r\n\r\n[demo 汇总](https://codesandbox.io/s/admiring-darkness-5lbuk)\r\n\r\n[详细描述](https://frontarm.com/james-k-nelson/react-context-performance/)\r\n\r\n因为provide创建的时候 比对Children 每一次创建的provide的Children 必然不相等。\r\n\r\n应该将Provide拿出来，然后对Provide进行props.children调用。这样以来，组件create的children\r\n\r\n就可以进行差异性比较了。","author":"ZWkang","databaseId":481864069,"id":"MDU6SXNzdWU0ODE4NjQwNjk=","lastEditedAt":"2019-08-17T08:58:32Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/481864069","bodyHTML":"<p>此篇主要是使用context api一些避免无谓re-render的场景</p>\n<p><a href=\"https://codesandbox.io/s/admiring-darkness-5lbuk\">demo 汇总</a></p>\n<p><a href=\"https://frontarm.com/james-k-nelson/react-context-performance/\">详细描述</a></p>\n<p>因为provide创建的时候 比对Children 每一次创建的provide的Children 必然不相等。</p>\n<p>应该将Provide拿出来，然后对Provide进行props.children调用。这样以来，组件create的children</p>\n<p>就可以进行差异性比较了。</p>\n","preview":"此篇主要是使用context api一些避免无谓re-render的场景  demo 汇总  详细描述  因为provide创建的时候 比对Children 每一次创建的provide的Children 必然不相等。 ..."},"488688020":{"title":"react cookbook note","createdAt":"2019-09-03T15:52:58Z","state":"OPEN","labels":[],"body":"- 无状态函数\r\n- JSX扩展属性\r\n- 解构参数\r\n- 条件渲染\r\n- 子元素类型\r\n- 数组做为子元素\r\n- 函数作为子元素\r\n- 渲染回调\r\n- 子元素传递\r\n- 代理组件\r\n- 样式组件\r\n- 事件转换\r\n- 布局组件\r\n- 容器组件\r\n- 高阶组件\r\n- 状态提升\r\n- 可控的input\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 无状态函数\r\n```\r\n// 推崇原因在于，无状态组件很简单，我们可以将它仅仅作为函数，它的内部并不保存状态\r\n\r\na=> a alway a\r\n\r\nfunction Test() {\r\n    return <h1>tesrt<h1>\r\n}\r\n\r\n```\r\n- JSX扩展属性\r\n```\r\n扩展属性是一个JSX特性。这是用于将所有对象的属性作为JSX属性传递的语法糖。\r\n\r\n// 写作属性的props\r\n<main className=\"main\" role=\"main\">{children}</main>\r\n\r\n// 从对象中扩展的props\r\n<main {...{className: \"main\", role: \"main\", children}} />\r\n\r\n// 子组件封装以后 我们可以很好地使用这种传递性做render\r\n```\r\n\r\n\r\n- 解构参数\r\n```js\r\n解构赋值是ES6的新东西\r\n\r\n其中要了解的扩展运算符\r\n\r\n\r\n\r\nfunction Test(props) {\r\n    return <h1>{props.test}<h1>\r\n}\r\n\r\nfunction Test({test}) {\r\n    return <h1>{test}</h1>\r\n}\r\n\r\nconst Greeting = ({ name, ...props }) =>\r\n  <div {...props}>Hi {name}!</div>\r\n  \r\n//还可以对值做过滤\r\nconst propsThrought = {\r\n    name: 'kang'\r\n}\r\nconst Greeting = ({ name, ...props }) =>\r\n  <div {...props} {...propsThrought}>Hi {name}!</div>\r\n\r\n```\r\n- 条件渲染\r\n\r\n[条件渲染演示](https://codesandbox.io/s/wqvlpqn2z5)\r\n```\r\nfunction Test({isRender}) {\r\n    return isRender ? <h1>render</h1> : <h1>no render</h1>\r\n}\r\n\r\n```\r\n\r\n- 子元素类型\r\n```\r\nchildren支持多种形式渲染\r\n\r\nstring\r\n\r\n<div>string</div>\r\n\r\narray\r\n\r\n<div>{[1,2,3,4,5].map(v => <span>v</span>)}</div>\r\n// https://codesandbox.io/s/m45p31191y\r\n\r\nfunction (需要与父组件协调children的输出)\r\n\r\nfunction Text(props) {\r\n  if (typeof props.children) {\r\n    return props.children();\r\n  } else {\r\n    return props.children;\r\n  }\r\n}\r\n\r\n<Text>{() => <div>test</div>}</Text>\r\n\r\n// https://codesandbox.io/s/72n5jpkp36\r\n\r\n```\r\n\r\n- 数组做为子元素\r\n```\r\n<div>{[1,2,3,4,5].map(v => <span>v</span>)}</div>\r\n// https://codesandbox.io/s/m45p31191y\r\n\r\n\r\n子元素是一个元素集合\r\n```\r\n- 函数作为子元素\r\n```\r\nfunction (需要与父组件协调children的输出)\r\n\r\nfunction Text(props) {\r\n  if (typeof props.children) {\r\n    return props.children();\r\n  } else {\r\n    return props.children;\r\n  }\r\n}\r\n\r\n<Text>{() => <div>test</div>}</Text>\r\n\r\n// https://codesandbox.io/s/72n5jpkp36\r\n```\r\n- 渲染回调\r\n```\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <div>\r\n        <Text>{v => RenderName(v)}</Text>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\nfunction RenderName({ name }) {\r\n  return <h1>{name}</h1>;\r\n}\r\nfunction Text(props) {\r\n  if (typeof props.children) {\r\n    return props.children({\r\n      name: \"ZWKang\"\r\n    });\r\n  } else {\r\n    return props.children;\r\n  }\r\n}\r\n\r\n这种情况的好处是 父元素只充当了数据提供者。\r\n而数据消费者权利交给了callback处理\r\n```\r\n- 子元素传递\r\n```\r\nclass SomeContextProvider extends React.Component {\r\n  getChildContext() {\r\n    return {some: \"context\"}\r\n  }\r\n\r\n  render() {\r\n    // how best do we return `children`?\r\n  }\r\n}\r\n\r\n// 此时选择返回子元素的方式\r\n\r\n// option 1: 额外的div\r\nreturn <div>{children}</div> // 新版本应该不是问题\r\n\r\n// option 2: 无益的错误\r\nreturn children\r\n\r\n作者推荐 最好把子元素当成一种不透明的数据类型。React提供React.Children来适当地处理子元素。\r\n\r\n\r\nreturn React.Children.only(this.props.children)\r\n\r\n```\r\n- 代理组件\r\n```\r\n抽象某些组件公共部分形成代理组件 用来省去重复元素属性\r\n\r\n<button type=\"button\">\r\n\r\n=>\r\n\r\nconst Button = props =>\r\n  <button type=\"button\" {...props}>\r\n  \r\n<Button />\r\n// <button type=\"button\"><button>\r\n\r\n<Button className=\"CTA\">Send Money</Button>\r\n// <button type=\"button\" class=\"CTA\">Send Money</button>\r\n```\r\n- 样式组件\r\n```\r\n将样式分离到各个组件中\r\n如果我们需要这么一个组件\r\n<button type=\"button\" className=\"btn btn-primary\">\r\n\r\n=>\r\n\r\nimport classnames from 'classnames'\r\n\r\nconst PrimaryBtn = props =>\r\n  <Btn {...props} primary />\r\n\r\nconst Btn = ({ className, primary, ...props }) =>\r\n  <button\r\n    type=\"button\"\r\n    className={classnames(\r\n      \"btn\",\r\n      primary && \"btn-primary\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n  \r\nPrimaryBtn()\r\n  ↳ Btn({primary: true})\r\n    ↳ Button({className: \"btn btn-primary\"}, type: \"button\"})\r\n      ↳ '<button type=\"button\" class=\"btn btn-primary\"></button>'\r\n\r\n将组件在每层中进行状态的分发，以保证单个状态不至于紊乱。\r\n也方便组合\r\n```\r\n\r\n- 事件转换\r\n```\r\n使用一个函数 对多个事件类型进行处理\r\n\r\nhandleEvent({type}) {\r\n  switch(type) {\r\n    case \"click\":\r\n      return require(\"./actions/doStuff\")(/* action dates */)\r\n    case \"mouseenter\":\r\n      return this.setState({ hovered: true })\r\n    case \"mouseleave\":\r\n      return this.setState({ hovered: false })\r\n    default:\r\n      return console.warn(`No case for event type \"${type}\"`)\r\n  }\r\n}\r\n\r\n\r\n在遇到问题之前，不要担心性能优化问题。真的不要。\r\n```\r\n- 布局组件\r\n```\r\n布局组件会导致某种形式的静态DOM元素。如果有的话，它可能不需要经常更新。\r\n\r\n<HorizontalSplit\r\n  leftSide={<SomeSmartComponent />}\r\n  rightSide={<AnotherSmartComponent />}\r\n/>\r\n\r\n虽然 HorizontalSplit 将成为这两个组件的父组件，但它永远不会是他们的所有者。我们可以告诉它永远不更新，而不会中断组件的生命周期。\r\n(只是当前的HorizontalSplit 不会rerender  但是子组件的re render还会继续)\r\n\r\n\r\nclass HorizontalSplit extends React.Component {\r\n  shouldComponentUpdate() {\r\n    return false\r\n  }\r\n\r\n  render() {\r\n    <FlexContainer>\r\n      <div>{this.props.leftSide}</div>\r\n      <div>{this.props.rightSide}</div>\r\n    </FlexContainer>\r\n  }\r\n}\r\n```\r\n- 容器组件\r\n```\r\n我们一般让处理数据  与数据状态打交道的上层组件称为容器组件\r\n\r\n他一般是接纳无状态组件 也就是展示型组件直接render，也就是控制点移交一处\r\n\r\n\r\nconst CommentList = ({ comments }) =>\r\n  <ul>\r\n    {comments.map(comment =>\r\n      <li>{comment.body}-{comment.author}</li>\r\n    )}\r\n  </ul>\r\n  \r\n class CommentListContainer extends React.Component {\r\n  constructor() {\r\n    super()\r\n    this.state = { comments: [] }\r\n  }\r\n\r\n  componentDidMount() {\r\n    $.ajax({\r\n      url: \"/my-comments.json\",\r\n      dataType: 'json',\r\n      success: comments =>\r\n        this.setState({comments: comments}); // 数据获取\r\n    })\r\n  }\r\n\r\n  render() {\r\n    return <CommentList comments={this.state.comments} /> //render数据\r\n  }\r\n}\r\n```\r\n- 高阶组件\r\n```\r\n高阶组件一般是存储一些可复用逻辑，可复用类型。\r\n\r\n我们可以直接patch到组件内。\r\n不过还是还注意静态方法的传递，props名字的重复，高阶组件的传递，样板代码过多。\r\n\r\n\r\nconst Greeting = ({ name }) => {\r\n  if (!name) { return <div>Connecting...</div> }\r\n\r\n  return <div>Hi {name}!</div>\r\n}\r\n\r\nconst Connect = ComposedComponent =>\r\n  class extends React.Component {\r\n    constructor() {\r\n      super()\r\n      this.state = { name: \"\" }\r\n    }\r\n\r\n    componentDidMount() {\r\n      // this would fetch or connect to a store\r\n      this.setState({ name: \"Michael\" })\r\n    }\r\n\r\n    render() {\r\n      return (\r\n        <ComposedComponent\r\n          {...this.props}\r\n          name={this.state.name}\r\n        />\r\n      )\r\n    }\r\n  }\r\n  \r\n  const ConnectedMyComponent = Connect(Greeting)\r\n```\r\n\r\n这是为任何数量的**无状态函数组件**提供**获取**和**绑定数据**的强大模式。\r\n\r\n- 状态提升\r\n子组件可以通过父组件传递的callback 去影响父组件状态\r\n\r\n```\r\nclass NameContainer extends React.Component {\r\n  render() {\r\n    return <Name onChange={newName => alert(newName)} />\r\n  }\r\n}\r\n\r\nconst Name = ({ onChange }) =>\r\n  <input onChange={e => onChange(e.target.value)} />\r\n  \r\nclass NameContainer extends React.Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {name: \"\"}\r\n  }\r\n\r\n  render() {\r\n    return <Name onChange={newName => this.setState({name: newName})} />\r\n  }\r\n}\r\n```\r\n\r\n- 可控的input\r\n\r\n受控组件常常是需要一个state来维护表单字段数据\r\n\r\n而非受控组件常常是直接通过取得ref input元素的值进行处理\r\n\r\n\r\n---\r\n\r\n### link\r\n\r\n- [reactpatterns 参照内容](https://github.com/chantastic/reactpatterns)\r\n- [reactpatterns 参照翻译](https://github.com/yueshuiniao/reactpatterns.com)","author":"ZWkang","databaseId":488688020,"id":"MDU6SXNzdWU0ODg2ODgwMjA=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/488688020","bodyHTML":"<ul>\n<li>无状态函数</li>\n<li>JSX扩展属性</li>\n<li>解构参数</li>\n<li>条件渲染</li>\n<li>子元素类型</li>\n<li>数组做为子元素</li>\n<li>函数作为子元素</li>\n<li>渲染回调</li>\n<li>子元素传递</li>\n<li>代理组件</li>\n<li>样式组件</li>\n<li>事件转换</li>\n<li>布局组件</li>\n<li>容器组件</li>\n<li>高阶组件</li>\n<li>状态提升</li>\n<li>可控的input</li>\n</ul>\n<hr>\n<ul>\n<li>无状态函数</li>\n</ul>\n<pre><code>// 推崇原因在于，无状态组件很简单，我们可以将它仅仅作为函数，它的内部并不保存状态\n\na=&gt; a alway a\n\nfunction Test() {\n    return &lt;h1&gt;tesrt&lt;h1&gt;\n}\n\n</code></pre>\n<ul>\n<li>JSX扩展属性</li>\n</ul>\n<pre><code>扩展属性是一个JSX特性。这是用于将所有对象的属性作为JSX属性传递的语法糖。\n\n// 写作属性的props\n&lt;main className=&quot;main&quot; role=&quot;main&quot;&gt;{children}&lt;/main&gt;\n\n// 从对象中扩展的props\n&lt;main {...{className: &quot;main&quot;, role: &quot;main&quot;, children}} /&gt;\n\n// 子组件封装以后 我们可以很好地使用这种传递性做render\n</code></pre>\n<ul>\n<li>解构参数</li>\n</ul>\n<pre><code class=\"language-js\">解构赋值是ES6的新东西\n\n其中要了解的扩展运算符\n\n\n\nfunction Test(props) {\n    return &lt;h1&gt;{props.test}&lt;h1&gt;\n}\n\nfunction Test({test}) {\n    return &lt;h1&gt;{test}&lt;/h1&gt;\n}\n\nconst Greeting = ({ name, ...props }) =&gt;\n  &lt;div {...props}&gt;Hi {name}!&lt;/div&gt;\n  \n//还可以对值做过滤\nconst propsThrought = {\n    name: 'kang'\n}\nconst Greeting = ({ name, ...props }) =&gt;\n  &lt;div {...props} {...propsThrought}&gt;Hi {name}!&lt;/div&gt;\n\n</code></pre>\n<ul>\n<li>条件渲染</li>\n</ul>\n<p><a href=\"https://codesandbox.io/s/wqvlpqn2z5\">条件渲染演示</a></p>\n<pre><code>function Test({isRender}) {\n    return isRender ? &lt;h1&gt;render&lt;/h1&gt; : &lt;h1&gt;no render&lt;/h1&gt;\n}\n\n</code></pre>\n<ul>\n<li>子元素类型</li>\n</ul>\n<pre><code>children支持多种形式渲染\n\nstring\n\n&lt;div&gt;string&lt;/div&gt;\n\narray\n\n&lt;div&gt;{[1,2,3,4,5].map(v =&gt; &lt;span&gt;v&lt;/span&gt;)}&lt;/div&gt;\n// https://codesandbox.io/s/m45p31191y\n\nfunction (需要与父组件协调children的输出)\n\nfunction Text(props) {\n  if (typeof props.children) {\n    return props.children();\n  } else {\n    return props.children;\n  }\n}\n\n&lt;Text&gt;{() =&gt; &lt;div&gt;test&lt;/div&gt;}&lt;/Text&gt;\n\n// https://codesandbox.io/s/72n5jpkp36\n\n</code></pre>\n<ul>\n<li>数组做为子元素</li>\n</ul>\n<pre><code>&lt;div&gt;{[1,2,3,4,5].map(v =&gt; &lt;span&gt;v&lt;/span&gt;)}&lt;/div&gt;\n// https://codesandbox.io/s/m45p31191y\n\n\n子元素是一个元素集合\n</code></pre>\n<ul>\n<li>函数作为子元素</li>\n</ul>\n<pre><code>function (需要与父组件协调children的输出)\n\nfunction Text(props) {\n  if (typeof props.children) {\n    return props.children();\n  } else {\n    return props.children;\n  }\n}\n\n&lt;Text&gt;{() =&gt; &lt;div&gt;test&lt;/div&gt;}&lt;/Text&gt;\n\n// https://codesandbox.io/s/72n5jpkp36\n</code></pre>\n<ul>\n<li>渲染回调</li>\n</ul>\n<pre><code>function App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;div&gt;\n        &lt;Text&gt;{v =&gt; RenderName(v)}&lt;/Text&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\nfunction RenderName({ name }) {\n  return &lt;h1&gt;{name}&lt;/h1&gt;;\n}\nfunction Text(props) {\n  if (typeof props.children) {\n    return props.children({\n      name: &quot;ZWKang&quot;\n    });\n  } else {\n    return props.children;\n  }\n}\n\n这种情况的好处是 父元素只充当了数据提供者。\n而数据消费者权利交给了callback处理\n</code></pre>\n<ul>\n<li>子元素传递</li>\n</ul>\n<pre><code>class SomeContextProvider extends React.Component {\n  getChildContext() {\n    return {some: &quot;context&quot;}\n  }\n\n  render() {\n    // how best do we return `children`?\n  }\n}\n\n// 此时选择返回子元素的方式\n\n// option 1: 额外的div\nreturn &lt;div&gt;{children}&lt;/div&gt; // 新版本应该不是问题\n\n// option 2: 无益的错误\nreturn children\n\n作者推荐 最好把子元素当成一种不透明的数据类型。React提供React.Children来适当地处理子元素。\n\n\nreturn React.Children.only(this.props.children)\n\n</code></pre>\n<ul>\n<li>代理组件</li>\n</ul>\n<pre><code>抽象某些组件公共部分形成代理组件 用来省去重复元素属性\n\n&lt;button type=&quot;button&quot;&gt;\n\n=&gt;\n\nconst Button = props =&gt;\n  &lt;button type=&quot;button&quot; {...props}&gt;\n  \n&lt;Button /&gt;\n// &lt;button type=&quot;button&quot;&gt;&lt;button&gt;\n\n&lt;Button className=&quot;CTA&quot;&gt;Send Money&lt;/Button&gt;\n// &lt;button type=&quot;button&quot; class=&quot;CTA&quot;&gt;Send Money&lt;/button&gt;\n</code></pre>\n<ul>\n<li>样式组件</li>\n</ul>\n<pre><code>将样式分离到各个组件中\n如果我们需要这么一个组件\n&lt;button type=&quot;button&quot; className=&quot;btn btn-primary&quot;&gt;\n\n=&gt;\n\nimport classnames from 'classnames'\n\nconst PrimaryBtn = props =&gt;\n  &lt;Btn {...props} primary /&gt;\n\nconst Btn = ({ className, primary, ...props }) =&gt;\n  &lt;button\n    type=&quot;button&quot;\n    className={classnames(\n      &quot;btn&quot;,\n      primary &amp;&amp; &quot;btn-primary&quot;,\n      className\n    )}\n    {...props}\n  /&gt;\n  \nPrimaryBtn()\n  ↳ Btn({primary: true})\n    ↳ Button({className: &quot;btn btn-primary&quot;}, type: &quot;button&quot;})\n      ↳ '&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/button&gt;'\n\n将组件在每层中进行状态的分发，以保证单个状态不至于紊乱。\n也方便组合\n</code></pre>\n<ul>\n<li>事件转换</li>\n</ul>\n<pre><code>使用一个函数 对多个事件类型进行处理\n\nhandleEvent({type}) {\n  switch(type) {\n    case &quot;click&quot;:\n      return require(&quot;./actions/doStuff&quot;)(/* action dates */)\n    case &quot;mouseenter&quot;:\n      return this.setState({ hovered: true })\n    case &quot;mouseleave&quot;:\n      return this.setState({ hovered: false })\n    default:\n      return console.warn(`No case for event type &quot;${type}&quot;`)\n  }\n}\n\n\n在遇到问题之前，不要担心性能优化问题。真的不要。\n</code></pre>\n<ul>\n<li>布局组件</li>\n</ul>\n<pre><code>布局组件会导致某种形式的静态DOM元素。如果有的话，它可能不需要经常更新。\n\n&lt;HorizontalSplit\n  leftSide={&lt;SomeSmartComponent /&gt;}\n  rightSide={&lt;AnotherSmartComponent /&gt;}\n/&gt;\n\n虽然 HorizontalSplit 将成为这两个组件的父组件，但它永远不会是他们的所有者。我们可以告诉它永远不更新，而不会中断组件的生命周期。\n(只是当前的HorizontalSplit 不会rerender  但是子组件的re render还会继续)\n\n\nclass HorizontalSplit extends React.Component {\n  shouldComponentUpdate() {\n    return false\n  }\n\n  render() {\n    &lt;FlexContainer&gt;\n      &lt;div&gt;{this.props.leftSide}&lt;/div&gt;\n      &lt;div&gt;{this.props.rightSide}&lt;/div&gt;\n    &lt;/FlexContainer&gt;\n  }\n}\n</code></pre>\n<ul>\n<li>容器组件</li>\n</ul>\n<pre><code>我们一般让处理数据  与数据状态打交道的上层组件称为容器组件\n\n他一般是接纳无状态组件 也就是展示型组件直接render，也就是控制点移交一处\n\n\nconst CommentList = ({ comments }) =&gt;\n  &lt;ul&gt;\n    {comments.map(comment =&gt;\n      &lt;li&gt;{comment.body}-{comment.author}&lt;/li&gt;\n    )}\n  &lt;/ul&gt;\n  \n class CommentListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = { comments: [] }\n  }\n\n  componentDidMount() {\n    $.ajax({\n      url: &quot;/my-comments.json&quot;,\n      dataType: 'json',\n      success: comments =&gt;\n        this.setState({comments: comments}); // 数据获取\n    })\n  }\n\n  render() {\n    return &lt;CommentList comments={this.state.comments} /&gt; //render数据\n  }\n}\n</code></pre>\n<ul>\n<li>高阶组件</li>\n</ul>\n<pre><code>高阶组件一般是存储一些可复用逻辑，可复用类型。\n\n我们可以直接patch到组件内。\n不过还是还注意静态方法的传递，props名字的重复，高阶组件的传递，样板代码过多。\n\n\nconst Greeting = ({ name }) =&gt; {\n  if (!name) { return &lt;div&gt;Connecting...&lt;/div&gt; }\n\n  return &lt;div&gt;Hi {name}!&lt;/div&gt;\n}\n\nconst Connect = ComposedComponent =&gt;\n  class extends React.Component {\n    constructor() {\n      super()\n      this.state = { name: &quot;&quot; }\n    }\n\n    componentDidMount() {\n      // this would fetch or connect to a store\n      this.setState({ name: &quot;Michael&quot; })\n    }\n\n    render() {\n      return (\n        &lt;ComposedComponent\n          {...this.props}\n          name={this.state.name}\n        /&gt;\n      )\n    }\n  }\n  \n  const ConnectedMyComponent = Connect(Greeting)\n</code></pre>\n<p>这是为任何数量的<strong>无状态函数组件</strong>提供<strong>获取</strong>和<strong>绑定数据</strong>的强大模式。</p>\n<ul>\n<li>状态提升<br>\n子组件可以通过父组件传递的callback 去影响父组件状态</li>\n</ul>\n<pre><code>class NameContainer extends React.Component {\n  render() {\n    return &lt;Name onChange={newName =&gt; alert(newName)} /&gt;\n  }\n}\n\nconst Name = ({ onChange }) =&gt;\n  &lt;input onChange={e =&gt; onChange(e.target.value)} /&gt;\n  \nclass NameContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = {name: &quot;&quot;}\n  }\n\n  render() {\n    return &lt;Name onChange={newName =&gt; this.setState({name: newName})} /&gt;\n  }\n}\n</code></pre>\n<ul>\n<li>可控的input</li>\n</ul>\n<p>受控组件常常是需要一个state来维护表单字段数据</p>\n<p>而非受控组件常常是直接通过取得ref input元素的值进行处理</p>\n<hr>\n<h3>link</h3>\n<ul>\n<li><a href=\"https://github.com/chantastic/reactpatterns\">reactpatterns 参照内容</a></li>\n<li><a href=\"https://github.com/yueshuiniao/reactpatterns.com\">reactpatterns 参照翻译</a></li>\n</ul>\n","preview":"无状态函数 JSX扩展属性 解构参数 条件渲染 子元素类型 数组做为子元素 函数作为子元素 渲染回调 子元素传递 代理组件 样式组件 事件转换 布局组件 容器组件 高阶组件 状态提升 可控的input        无状态函数 ` //..."},"492258365":{"title":"redux link","createdAt":"2019-09-11T14:01:57Z","state":"OPEN","labels":[],"body":"https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840","author":"ZWkang","databaseId":492258365,"id":"MDU6SXNzdWU0OTIyNTgzNjU=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/492258365","bodyHTML":"<p>https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840</p>\n","preview":"https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840..."},"493690753":{"title":"阅读 React性能优化-虚拟Dom原理浅析","createdAt":"2019-09-15T03:33:17Z","state":"OPEN","labels":[],"body":"在虚拟dom的比较，除了一些根据优化算法进行的优化外，还需要切记，避免传递的引用。\r\n\r\n### JSX的背后\r\n\r\n","author":"ZWkang","databaseId":493690753,"id":"MDU6SXNzdWU0OTM2OTA3NTM=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/493690753","bodyHTML":"<p>在虚拟dom的比较，除了一些根据优化算法进行的优化外，还需要切记，避免传递的引用。</p>\n<h3>JSX的背后</h3>\n","preview":"在虚拟dom的比较，除了一些根据优化算法进行的优化外，还需要切记，避免传递的引用。  JSX的背后  ..."},"493708721":{"title":"react-router源码解析","createdAt":"2019-09-15T08:10:07Z","state":"OPEN","labels":[],"body":"https://github.com/ReactTraining/react-router/issues/6060#issuecomment-424575126","author":"ZWkang","databaseId":493708721,"id":"MDU6SXNzdWU0OTM3MDg3MjE=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/493708721","bodyHTML":"<p>https://github.com/ReactTraining/react-router/issues/6060#issuecomment-424575126</p>\n","preview":"https://github.com/ReactTraining/react-router/issues/6060#issuecomment-424575126..."},"529135091":{"title":"React Error Boundaries","createdAt":"2019-11-27T06:00:50Z","state":"OPEN","labels":[],"body":"新版的React已经存在  Error Boundaries 错误边界的模式。。\r\n\r\nhttps://zh-hans.reactjs.org/docs/error-boundaries.html\r\n\r\n\r\n在我们开发组件的时候一个组件的error throw 会导致整份应用失效。\r\n\r\n错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。\r\n\r\n无法处理的错误\r\n\r\n事件处理（了解更多）\r\n异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\r\n服务端渲染\r\n它自身抛出来的错误（并非它的子组件）\r\n\r\n\r\n更适用于组件分块的情况下，一部分失败不会影响另一部分的交互。\r\n\r\n异常捕获后的UI控制标记。 getDerivedStateFromError，用一个state hasError 来标记当前组件是否报异常了，可以利用这个state来决定是否显示降级UI；\r\n\r\n异常捕获后的回调componentDidCatch，会在“commit”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：\r\n\r\n异常捕获后的自定义降级UI。\r\n\r\n\r\n","author":"ZWkang","databaseId":529135091,"id":"MDU6SXNzdWU1MjkxMzUwOTE=","lastEditedAt":null,"sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/529135091","bodyHTML":"<p>新版的React已经存在  Error Boundaries 错误边界的模式。。</p>\n<p>https://zh-hans.reactjs.org/docs/error-boundaries.html</p>\n<p>在我们开发组件的时候一个组件的error throw 会导致整份应用失效。</p>\n<p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>\n<p>无法处理的错误</p>\n<p>事件处理（了解更多）<br>\n异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）<br>\n服务端渲染<br>\n它自身抛出来的错误（并非它的子组件）</p>\n<p>更适用于组件分块的情况下，一部分失败不会影响另一部分的交互。</p>\n<p>异常捕获后的UI控制标记。 getDerivedStateFromError，用一个state hasError 来标记当前组件是否报异常了，可以利用这个state来决定是否显示降级UI；</p>\n<p>异常捕获后的回调componentDidCatch，会在“commit”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：</p>\n<p>异常捕获后的自定义降级UI。</p>\n","preview":"新版的React已经存在  Error Boundaries 错误边界的模式。。  https://zh-hans.reactjs.org/docs/error-boundaries.html   在我们开发组件的时候一个组件的error..."},"778548529":{"title":"数据流","createdAt":"2021-01-05T03:35:07Z","state":"OPEN","labels":[],"body":" sorrycc blog issues 1\r\ndva的设计思想","author":"ZWkang","databaseId":778548529,"id":"MDU6SXNzdWU3Nzg1NDg1Mjk=","lastEditedAt":"2021-01-05T03:35:56Z","sourceExt":"md","parseExt":"html","prefix":"","virtualPath":"/post/778548529","bodyHTML":"<p>sorrycc blog issues 1<br>\ndva的设计思想</p>\n","preview":" sorrycc blog issues 1 dva的设计思想..."}}